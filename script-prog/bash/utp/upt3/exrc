" Keymaps for the vi editor
"
" As you browse through this file, if you see customizations you'd
" like to add to your setup, remove the comment characters (the
" first two characters on each line: a double quote and a space)
" and add the lines to the .exrc file in your home directory.
"
" Many of the characters in this file are "special" characters --
" mostly control characters.  (For instance, what looks like ^H
" isn't the two characters ^ and H; it's a backspace character.)
" You can recognize these by moving your cursor across them: if
" it slides past the ^ character and onto the second character,
" it's a single character.  For more information, see Unix Power
" Tools third edition article 18.6.
"
" Note that these maps are for the original vi.  Newer versions such
" as vim use some of the keys that weren't originally used in vi.
" If one of these overrides a key you use for something else, you
" can simply change it to define a different key (or key sequence).
" Some of these do things that are already available in newer vi's.
" You may also find that some of these -- like the text input mode
" map for ^J in the first section below -- don't work in your version
" of vi.  Please test modify these if needed.
" 
" " - - - - - - - - - - - -
" 
" " Map ctrl-h, ctrl-j, ctrl-k and ctrl-l to to move the cursor during
" " test-input mode, just as the commands h, j, k, and l do in command mode.
" map!  i
" map!  ka
" map!  la
" map! 
"  ja
" " Note: the two lines above map ^J (LINEFEED)
" 
" " - - - - - - - - - - - -
" 
" " Maps for cutting (Kut) the current line by replacing a space with a
" " carriage return at or before the 78th character.
" "
" " Uncomment one or the other; the first one doesn't seem to work on
" " some versions of vi.
" "
" " This one uses | to move to column 78
" map K 78|lBhr
" " This one counts tabs as single characters
" "map K 078lF r
" 
" " - - - - - - - - - - - -
" 
" " Set 'exact' input mode for pasting exactly what is entered:
" map!  :se noai wm=0a
" " Set 'normal' input mode with usual autoindent and wrapmargn:
" map!  :se ai wm=8a
" " Read pasted text, clean up lines with fmt.  Type CTRL-D when done:
" map!  :r!fmt
" 
" " - - - - - - - - - - - -
" 
" " Filter through maps
" "
" " Map the F4 key during command mode to set the noautowrite opetion
" " (:se aw), write the buffer to your file (:w), delete all lines in the
" " buffer (:%d), and start a shell command line (:r !).
" map #4 :se noaw:w:%d:r !
" "
" " Put a spaec between the command line you type and the filename (^V ),
" " output the current filename followed by a return to execute the
" " command (%^M), delete the blank line generated by reading the Unix
" " command (:1d), and turn on the autowrite option again (:se aw).
" map! #4  '%':1d:se aw
" 
" " - - - - - - - - - - - -
" 
" " Abbreviations to "cut and paste" between vi sessions using temporary files.
" "
" " Write to a temporary file
" ab aW w! /tmp/jerry.temp.a
" " Insert contents of temporary file
" ab aR r /tmp/jerry.temp.a
" ab bW w! /tmp/jerry.temp.b
" ab bR r /tmp/jerry.temp.b
" 
" " - - - - - - - - - - - -
"
" " Tom Christiansen's grab-bag collection of keymaps
" 
" "	INPUT MACROS that i always want active
" "
" map!  :stop
" "	so i can stop in input mode.  note that autowrite is set, so 
" map!  :stop!
" "	will stop me without writing.
" "
" map!  O
" "	lets me do kind of a negative carriage return in input mode.
" map!  bi
" "	non-destructive ^W
" map!  Ea
" "	and its inverse
" "
" "	EMACS Style ARROW MACROS
" "
" map!  i
" map!  lli
" map!  I
" map!  A
" "
" "
" "	EXCHANGE MACROS -- for exchanging things
" "
" map v xp
" "	exchange current char with next one in edit mode
" map V :m+1
" "	exchange current line with next one in edit mode
" map!   hxpa
" "	exchange last typed char with penultimate one in insert mode
" map = 
" "	edit previously edited file
" "
" "	OTHER MACROS
" "
" map  :w
" "	write out the file
" "
" map * i
" "	split line
" "
" map  :stop!
" "	unconditional stop
" map Y y$
" "	so Y is analogous to C and D
" map  ddu
" "	single-line redraw
" map  :n +/
" "	go to next file in arg list, same position 
" "	useful for "vi +/string file1 file2 file3"
" "
" "
" "	META MACROS, all begin with meta-key '\' ; more later in file
" "
" map 	 \
" "	so can use both ^I and \ for meta-key
" "
" map \/ dePo/\< pA\> "wdd@w
" "	find current word, uses w buffer
" "
" "
" "	INVERT WORD CASE -- V is like W, v is like w.  3V is ok, only to EOL.
" "	uses both register n and mark n.
" map \v ywmnoP:s/./\~/g0"nDdd`n@n
" "	abc -> ABC    ABC->abc
" map \V yWmnoP:s/./\e~/g0"nDdd`n@n
" "	abc.xyz -> ABC.XYZ    ABC.XYZ->abc.xyz
" "
" "
" "	EXECUTION MACROS -- these two are for executing existing lines.  
" "
" map \@ "mdd@m
" "	execute line as a straight vi command (buffer m, use @@ to repeat)
" map \! 0i:r!"ndd@n
" "	execute line as :r! command (buffer n, use @@ to repeat)
" "
" map \t :r!cat /dev/tty
" "	read in stuff from X put buffer
" "	
" "
" "	BLOCK MACROS -- these help when dealing with C blocks
" "
" map!  {} O
" "	this will begin a block, leaving in insert mode
" map!  /}a
" "	and this will take you past its end, leaving in insert mode
" "
" "
" "
" "	LINT MACRO.  deletes all text from "lint output:" and below, (if any)
" "	replacing it with lint output in pretty block comment form.  could
" "	do sed work myself, but this is faster.  
" "
" "	the map! is for subsequent map, not by people, 
" "	though /^Lo would make sense.
" "	this is one of those famous time/space tradeoffs 
" "
" map! o lint output
" "
" "	and now for the real work
" map \l Go/* o/odG:wo/*** o<<:r!lint -u -lc %|sed 's/^/ *  /'Go***/N
" "
" "	indent this for me
" "
" map \i :%!indent -i4
" "
" "	COMMENTING MACROS -- these are actually pretty amazing
" "
" "	from edit mode, this comments a line
" map  	/* A */^
" "
" "	and this undoes it
" map  :s/\/\* \([^*]*\) \*\//\1
" "
" "	this next one defeats vi's tail-recursion defeatism
" "	called by 2 maps following this one 
" map!  :unmap! 
" "
" "	while in insert mode, this will put you "inside" a comment
" map!  :map!  aoa /*  */hhi
" "
" "	while in edit mode, this begins a block comment -- ^N to escape
" map \c	O/* *  */k:map!  *  A
" "
" "	and this is for adding more lines to a block comment -- ^N to escape
" map \	:map!  *  A
" "
" "
" map _ i_ll
" "	this character will now be underlined when less'd, rn'd, etc.
" "
" "	SPELL MACROS
" "
" map \s :wGo:$r!spell %
" "	spell the file, placing errors at bottom, use \n to find
" map \n Gdd\/
" "	for find next spelling error
" "
" "
" "	FORMATTING MACROS
" "
" map \P :.,$!fmt -75
" "	format thru end of document
" map \p !}fmt -75
" "	format paragraph
" map \f 1G/---:.,$!fmt -75
" "	format message (assumes MH Mail "comp" format)
" map \e :%!expand -4
" "	expand tabs to 4 stops
" "
" map \er 1G/^-/:r!sed -e '1,/^$/d' -e 's/^./> &/' @ /^-/j
" "	read in @, quoted (for MH replies, who link @ to current file)
" map \d :s/$/ $/$r 74|? s$xx0
" "	split line, like !!fmt but cheaper
" "
" "
" ab Jan January
" ab jan january 
" ab Feb February
" ab feb february
" ab Sep September
" ab sep september
" ab Oct October
" ab oct october
" ab Nov November
" ab nov november
" ab Dec December
" ab dec december
" ab Xmas Christmas
" ab xmas christmas
" ab Mon Monday
" ab mon monday
" ab Tue Tuesday
" ab tue tuesday
" ab Wed Wednesday
" ab wed wednesday
" ab Thu Thursday
" ab thu thursday
" ab Fri Friday
" ab fri friday
" ab Sat Saturday
" ab Sun Sunday
" ab Int International
" ab info information
" "
" " Line-centering macro by Greg Ubben, contributed for second edition
" " of UNIX Power Tools:
" map  80I $78hd0^D:s/  / /g$p
" 
" " - - - - - - - - - - - -
" 
" set ai redraw sm wm=1
" set tabstop=4
" set shiftwidth=4
" " great for auto indenting { } pairs:
" map! {} {}O	
" " cursor down while inserting:
" map! OD ja
" " vt100 up arrow while inserting:
" map! OA ka
" " cursor left while inserting:
" map! OB ha
" " cursor right:
" map! OC la
" " mapped pf1 to append to end of line:
" map  OP A
" " insert mode of the above:
" map! OP A 
" " mapped pf2 to insert before line:
" map  OQ 0i
" " insert mode of the above:
" map! OQ 0i
" " troff left quote:
" map! ``  \*(lq 
" " troff right quote:
" map! ''  \*(rq
" 
