From: "Saved by Windows Internet Explorer 8"
Subject: UNIX programming examples
Date: Fri, 7 Mar 2014 10:40:16 +0530
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_0000_01CF39F1.A09848F0"
X-MimeOLE: Produced By Microsoft MimeOLE V6.1.7601.17609

This is a multi-part message in MIME format.

------=_NextPart_000_0000_01CF39F1.A09848F0
Content-Type: text/html;
	charset="Windows-1252"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://mij.oltrelinux.com/devel/unixprg/

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>UNIX programming examples</TITLE>
<META content=3D"text/html; charset=3Dwindows-1252" =
http-equiv=3DContent-Type>
<META name=3Dkeywords=20
content=3D"example, IPC, Inter-process Communication, POSIX, UNIX, =
programming, kill, signal, pipe, mkfifo, socket, connect, bind, =
recvfrom, mq_open, mq_send, sem_wait, sem_post, shm_open, mmap, =
pthread_create, fork, waitpid, regcomp, regexec">
<STYLE type=3Dtext/css>DIV#sitelinks {
	WIDTH: 100%; OVERFLOW: hidden
}
#sitelinks UL {
	LIST-STYLE-TYPE: none; WIDTH: 50%; FLOAT: right
}
#sitelinks LI {
	TEXT-ALIGN: right
}
DIV#lastupdate {
	WIDTH: 100%; OVERFLOW: hidden
}
#lastupdate P {
	FLOAT: right; FONT-SIZE: x-small
}
DIV.ref_funcs {
	POSITION: relative; FONT-STYLE: italic; LEFT: 30px
}
DIV.csource {
	BORDER-BOTTOM: black 1px solid; TEXT-ALIGN: left; BORDER-LEFT: black =
1px solid; PADDING-BOTTOM: 0.5em; BACKGROUND-COLOR: #ffffff; =
PADDING-LEFT: 1em; PADDING-RIGHT: 1em; FONT-FAMILY: monospace; COLOR: =
#000000; FONT-SIZE: small; OVERFLOW: auto; BORDER-TOP: black 1px solid; =
BORDER-RIGHT: black 1px solid; PADDING-TOP: 0.5em
}
.ccom {
	COLOR: #236e25
}
.cpdr {
	COLOR: #683821
}
.ctyp {
	COLOR: #881350
}
.cfun {
	COLOR: #003369
}
.cval {
	COLOR: #0000ff
}
.cstr {
	COLOR: #760f15
}
UL.ref_funcs {
	LIST-STYLE-TYPE: square
}
TABLE.figures {
	BORDER-BOTTOM: 0px; BORDER-LEFT: 0px; PADDING-BOTTOM: 10px; =
PADDING-LEFT: 10px; WIDTH: 100%; PADDING-RIGHT: 10px; BORDER-TOP: 0px; =
BORDER-RIGHT: 0px; PADDING-TOP: 10px
}
</STYLE>

<META name=3DGENERATOR content=3D"MSHTML 8.00.7601.18365"></HEAD>
<BODY>
<DIV id=3Dsitelinks>
<UL>
  <LI><A href=3D"http://mij.oltrelinux.com/main.html">Home Page</A>=20
  <LI><A href=3D"http://mij.oltrelinux.com/devel/index.html">dev</A>=20
  <LI><A href=3D"http://mij.oltrelinux.com/contacts.html">contacts</A>=20
</LI></UL></DIV>
<HR>

<H1>UNIX programming examples</H1>
<DIV id=3Dlastupdate>
<P><A =
href=3D"http://mij.oltrelinux.com/changelogs_index.html#devel">l.u.=20
18/12/2005</A></P></DIV>This page is for those who have no time (or are =
too=20
lazy) to read lots of man pages. This is also a good starting point for =
getting=20
introduced to some UNIX programming concepts and to UNIX IPC (that's=20
Inter-Process Communication). The page covers several programming topics =
under=20
UNIX in a practical fashion. Each topic has one or more full source code =

examples, for further clarification. Of course, when the tight details =
are=20
needed, a complete reading of the appropriate man page is =
necessary.<BR>While=20
the Internet is rich with sites giving fragmentary examples on any =
particular=20
subject, this page tries to wrap up more wholly information about the =
most=20
common topics.=20
<H4>Subjects organization</H4>The page is organized by <I>subjects</I>. =
One=20
paragraph per subject, each paragraph having its <I>notes</I>, one=20
<I>summary</I> and one or more <I>source code examples</I>. Notes are =
made of a=20
brief intro on theory, and then infos about how UNIX implements the =
thing. Notes=20
are meant not to be read by developers who already roughly know what =
they're=20
searching about. There are summaries for that: they quickly list key =
aspects.=20
POSIX conformance plays a big role here.<BR>For every subject, some =
examples are=20
reported in plain text/html. Examples are ready to be compiled an run on =
most=20
OSes.<BR>It is possible to download <A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/mij-unixprg-srcs.zip">all=
 the=20
example sources in one package</A>, and to download <A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/mij-unixprg-htmlsrcs.zip"=
>all the=20
html highlighted sources in one package</A>.=20
<H4>Usage of these sources and this page</H4>Every source in this page, =
except=20
where explicitly reported otherwise, has been invented, written and =
tested by=20
myself. As far as I care, all these sources are public domain. In case =
you make=20
conspicuous use of them, I like that you include some reference to this =
work in=20
your credits.<BR>About the rest of the contents in the page, please =
avoid=20
copying it fully or in parts.<BR>In general, if you found this page =
useful,=20
consider including a link to it somewhere on the web. This will make the =
page=20
more easily accessible from search engines for others too.<BR>Any =
comment or=20
different feedback is welcome, just follow the link for the contact page =
in the=20
top, right of this document.<BR>I would like to thank Roberto Farina, =
who=20
encouraged this work and gave me the possibility to carry it out in =
spite of the=20
choking engagements in university.=20
<H2>General topics on UNIX programming</H2>The following entries cover =
some=20
general programming topics under UNIX:=20
<UL>
  <LI><A href=3D"http://mij.oltrelinux.com/devel/unixprg/#regex">Regular =

  expressions</A>=20
  <UL>
    <LI><A =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#regex_notes">notes</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#regex_summary">summary</=
A>=20
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#regex_examples">example<=
/A>=20
    </LI></UL>
  <LI><A =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#cmdline">Parsing the=20
  command line</A>=20
  <UL>
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#cmdline_notes">notes</A>=
=20
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#cmdline_summary">summary=
</A>=20
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#cmdline_examples">exampl=
es</A>=20
    </LI></UL>
  <LI><A href=3D"http://mij.oltrelinux.com/devel/unixprg/#tasks">Tasks, =
fork(),=20
  wait() and waitpid()</A>=20
  <UL>
    <LI><A =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#tasks_notes">notes</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#tasks_summary">summary</=
A>=20
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#tasks_examples">examples=
</A>=20
    </LI></UL>
  <LI><A =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#threads">Threads</A>=20
  <UL>
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#threads_notes">notes</A>=
=20
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#threads_summary">summary=
</A>=20
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#threads_examples">exampl=
es</A>=20
    </LI></UL></LI></UL>
<H2>Interprocess communication / UNIX IPC programming</H2>The following =
entries=20
cover topics specific to Inter-process communication mechanisms under =
UNIX:=20
<UL>
  <LI><A =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__signals">IPC:=20
  signals</A>=20
  <UL>
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__signals_notes">note=
s</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__signals_summary">su=
mmary</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__signals_examples">e=
xamples</A>=20
    </LI></UL>
  <LI><A =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__pipes">IPC:=20
  pipes</A>=20
  <UL>
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__pipes_notes">notes<=
/A>=20
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__pipes_summary">summ=
ary</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__pipes_examples">exa=
mples</A>=20
    </LI></UL>
  <LI><A =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__named_pipes">IPC:=20
  named pipes</A>=20
  <UL>
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__named_pipes_notes">=
notes</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__named_pipes_summary=
">summary</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__named_pipes_example=
s">examples</A>=20
    </LI></UL>
  <LI><A =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__sockets">IPC: BSD=20
  sockets</A>=20
  <UL>
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__sockets_notes">note=
s</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__sockets_summary">su=
mmary</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__sockets_examples">e=
xamples</A>=20
    </LI></UL>
  <LI><A =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_msgqs">IPC:=20
  POSIX Message queues</A>=20
  <UL>
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_msgqs_notes">=
notes</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_msgqs_summary=
">summary</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_msgqs_example=
s">examples</A>=20
    </LI></UL>
  <LI><A =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_sem">IPC:=20
  POSIX Semaphores</A>=20
  <UL>
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_sem_notes">no=
tes</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_sem_summary">=
summary</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_sem_examples"=
>examples</A>=20
    </LI></UL>
  <LI><A =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_shm">IPC:=20
  POSIX shared memory</A>=20
  <UL>
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_shm_notes">no=
tes</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_shm_summary">=
summary</A>=20

    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_shm_examples"=
>examples</A>=20
    </LI></UL>
  <LI><A =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_objects">IPC:=
=20
  notes on POSIX objects -- the POSIX objects mess</A>=20
  <UL>
    <LI><A=20
    =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_objects_notes=
">notes</A>=20
    </LI></UL></LI></UL>
<HR>
<A name=3Dregex>
<H3>Regular expressions</H3></A>
<DIV class=3Dref_funcs>
<UL>
  <LI>re_format(7)=20
  <LI>regex(3)=20
  <LI>regexp(3) </LI></UL></DIV><BR>
<DIV class=3Dnotes><A name=3Dregex_notes><B>Notes:</B></A><BR>In the =
language=20
theory, Regular Expressions are a metalanguage: a (formal) language to =
describe=20
languages. Regular expressions (RE) can only describe the family of=20
<I>regular</I> languages. Regular languages comprehend a small set of =
very=20
simple languages whose properties are leftover. Talking about computers, =
RE=20
refers to the language used for driving parser programs for recognizing =
strings.=20
Recognize some text means verify it satisfies the properties expressed =
by the=20
regular expression.<BR>RE define a set of special characters whose =
meaning is=20
shown below. Any character out of that list is matched as-is on the =
string=20
against which you check the rule. The full RE is obtained by =
concatenating=20
shorter regular expressions, starting from simple characters up to =
longer sub=20
expressions. For example, you can define the patter "^hi.[it's me]" and =
it won't=20
match the string "hi.it's me", but it will match "hi i" or "his" or even =
"hide".=20
This is because the following characters have a meta meaning while not =
appearing=20
escaped (prefixed by a "\"):=20
<UL>
  <LI><TT>.</TT> : one character (e.g. <TT>ab.d</TT> matches <Q>abcd</Q> =
and=20
  <Q>abed</Q>)=20
  <LI><TT>^</TT> and <TT>$</TT> : beginning and ending of the text (e.g. =

  <TT>^foo$</TT> matches <Q>foo</Q> but not <Q>fooa</Q>)=20
  <LI><TT>*</TT> and <TT>+</TT> : last <I>atom</I> matched 0-or-more and =

  1-or-more times. An atom being any sub-regular-expression (e.g. =
<TT>ab*</TT>=20
  matches <Q>a</Q> or <Q>abbb</Q> with any number of Bs, and <TT>head =
(elem )+=20
  tail</TT> matches an abstract <Q>list</Q> of at least one elem).=20
  <LI><TT>?</TT> : last atom is <Q>possible</Q>, appearing 0 or 1 times. =
(e.g.=20
  <TT>Donald (Ervin )?Knuth</TT> matches the name of the Professor with =
or=20
  without the midname part).=20
  <LI><TT>[</TT>content<TT>]</TT> : one of the chars specified in =
content. Here=20
  content can be for example "abcde" or a range like "a-e". You can also =
use=20
  ctype's families through contents like "[:space:]" or "[:lower:]" =
(e.g.=20
  <TT>[1-9][0-9]+</TT> matches any natural number, that does not begin =
with 0).=20
  <LI><TT>( )</TT>: brackets serve to <Q>pack</Q> sub-expressions, for=20
  readability or to associate them to quantifiers like <TT>? * + =
{x,y}</TT>=20
  (e.g. <TT>(X (content)+ Y)*</TT> identifies a list of 0 or more =
messages with=20
  header X and footer Y, but each having a non-empty payload).=20
  <LI><TT>{x,y}</TT> : last atom matches x or y times. ",y" can be =
omitted. An=20
  atom is the nearest part of the rule to the bound {} by left. (e.g.=20
  <TT>[a-z]{4,8}</TT> may define a valid password as a lowercase word =
between 4=20
  and 8 characters long)=20
  <LI><TT>|</TT> : the string matches if it matches either the regex at =
left or=20
  right of this sign. (e.g <TT>foo|bar</TT> matches either <Q>foo</Q> or =

  <Q>bar</Q>)=20
  <LI><TT>\</TT> : escape char, see below </LI></UL>You can make any of =
those=20
special chars matching itself by escaping it, like "\?" for '?' or "\\" =
for '\'.=20
Furthermore, you can create more complex expressions by composing REs =
using=20
parenthesization. The bigger RE can be specified by several <I>atoms</I> =
like=20
that: "me and (him|she)" and "((((this people:.* |that guys) are)|(noone =
is))=20
fried of mine)".<BR><BR>Text comparisons using REs are made easy by the =
regex=20
library. See Summary.<BR></DIV><BR>
<DIV class=3Dsummary><A name=3Dregex_summary><B>Summary:</B></A><BR>
<UL>
  <LI>what to #include: <TT>regex.h</TT>, (sometimes =
<TT>sys/types.h</TT> which=20
  uses off_t for ansi compiling)=20
  <LI>types used: <TT>regex_t</TT> which carries the RE pattern =
compiled,=20
  <TT>regmatch_t</TT> for reporting=20
  <LI>functions:=20
  <OL>
    <LI><TT>int <B>regcomp</B>(regex_t * restrict preg, const char * =
restrict=20
    pattern, int cflags)</TT><BR>compiles <TT>pattern</TT> into a binary =
format=20
    for performance purposes. <TT>preg</TT> will contain the result.=20
    <TT>cflags</TT> is commonly <TT>REG_EXTENDED|REG_ICASE</TT> ( modern =
re=20
    format + case-insensitive matching). regcomp returns 0 on success, =
non-zero=20
    on failure (see <TT>regerror</TT>).=20
    <LI><TT>int <B>regexec</B>(const regex_t * restrict preg, const char =
*=20
    restrict string, size_t nmatch, regmatch_t pmatch[restrict], int=20
    eflags)</TT><BR>matches the rule in <TT>preg</TT> against =
<TT>string</TT>.=20
    <TT>nmatch</TT> and <TT>cflags</TT> are commonly 0. <TT>pmatch</TT> =
commonly=20
    NULL. 0 is returned if the string matched. If it did not match,=20
    <TT>REG_NOMATCH</TT> is returned. Elseway it returns an error you =
can check=20
    with REG_* error codes, or with the following function if you want =
to output=20
    human-readable messages.=20
    <LI><TT>size_t <B>regerror</B>(int errcode, const regex_t * restrict =
preg,=20
    char * restrict errbuf, size_t errbuf_size)</TT><BR>fills =
<TT>errbuf</TT>=20
    with an error message clearly describing the error <TT>errcode</TT>. =

    <TT>errbuf_size</TT> limits the size of the error message. =
<TT>preg</TT> can=20
    be specified to make more precise the error message. <TT>NULL</TT> =
elseway.=20
    <LI><TT>void <B>regfree</B>(regex_t *preg)</TT><BR>frees space =
allocated by=20
    using <TT>preg</TT>. You could no longer use <TT>preg</TT> after =
this=20
  </LI></OL>
  <LI>other things to know:=20
  <UL>
    <LI>you can check a RE is well-formed by compiling it. The=20
    <TT>regcomp()</TT> function will return 0 for ok, REG_BADPAT for bad =

    pattern.=20
    <LI>regcomp compiles by default with the *OLD* RE format =
(REG_BASIC). You=20
    must explicitly specify the REG_EXTENDED flag to use the new format. =

    <LI>regexec supports a number of options. They are very often not =
needed=20
    (flag 0). </LI></UL></LI></UL></DIV><BR>
<DIV class=3Dexamples><A =
name=3Dregex_examples><B>Examples:</B></A><BR>1)=20
Reimplementing egrep's basic behaviour. Obtained text from standard =
input,=20
prints out those lines matching the regular expression got from command =
line. It=20
can be useful to test REs too. Follows the source file:=20
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  qegrep.c
 *
 *  compares its standard input against the regular
 *  expression given (on command line), and prints
 *  out those lines matching that RE.
 *
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on Mon Dec 29 2003.
 *  Original source file available on =
http://mij.oltrelinux.com/devel/unixprg/
 */</SPAN>

 <SPAN class=3Dccom>/* max error message length */</SPAN>
<SPAN class=3Dcpdr>#define MAX_ERR_LENGTH </SPAN><SPAN =
class=3Dcval>80</SPAN><SPAN class=3Dcpdr>
</SPAN> <SPAN class=3Dccom>/* max length of a line of text from stdin =
*/</SPAN>
<SPAN class=3Dcpdr>#define MAX_TXT_LENGTH </SPAN><SPAN =
class=3Dcval>600</SPAN><SPAN class=3Dcpdr>
</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
</SPAN> <SPAN class=3Dccom>/* for --ansi (see off_t in regex.h) =
*/</SPAN>
<SPAN class=3Dcpdr>#include &lt;sys/types.h&gt;
</SPAN> <SPAN class=3Dccom>/* for index(): */</SPAN>
<SPAN class=3Dcpdr>#include &lt;string.h&gt;
#include &lt;regex.h&gt;
</SPAN>

<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>(<SPAN =
class=3Dctyp>int</SPAN> argc, <SPAN class=3Dctyp>char</SPAN> *argv[]) {
     <SPAN class=3Dccom>/* will contain the regular expression */</SPAN>
    regex_t myre;
    <SPAN class=3Dctyp>int</SPAN> err;
    <SPAN class=3Dctyp>char</SPAN> err_msg[MAX_ERR_LENGTH];
    <SPAN class=3Dctyp>char</SPAN> text[MAX_TXT_LENGTH];
   =20
     <SPAN class=3Dccom>/* safe check on cmd line args */</SPAN>
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>( argc &lt; =
<SPAN class=3Dcval>2</SPAN> || argc &gt; <SPAN class=3Dcval>2</SPAN> ) {
        <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Usage:\n\tqegrep 'RE' &lt; file\n\tOR\n\techo \"string\" | =
qegrep 'RE'\n"</SPAN>);
        <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>1</SPAN>;
    }
   =20
     <SPAN class=3Dccom>/* compiles the RE. If this step fails, reveals =
what's wrong with the RE */</SPAN>
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>( (err =3D =
<SPAN class=3Dcfun>regcomp</SPAN>(&amp;myre, argv[<SPAN =
class=3Dcval>1</SPAN>], REG_EXTENDED)) !=3D <SPAN class=3Dcval>0</SPAN> =
) {
        <SPAN class=3Dcfun>regerror</SPAN>(err, &amp;myre, err_msg, =
MAX_ERR_LENGTH);
        <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Error =
analyzing regular expression '%s': %s.\n"</SPAN>, argv[<SPAN =
class=3Dcval>1</SPAN>], err_msg);
        <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>1</SPAN>;
    }
   =20
     <SPAN class=3Dccom>/* "executes" the RE against the text taken from =
stdin */</SPAN>
    <SPAN class=3Dctyp>while</SPAN><SPAN class=3Dcfun> </SPAN>( <SPAN =
class=3Dcfun>fgets</SPAN>(text, MAX_TXT_LENGTH, stdin) !=3D <SPAN =
class=3Dctyp>NULL</SPAN> ) {
         <SPAN class=3Dccom>/* we rely on the fact that text contains =
newline chars */</SPAN>
        *(<SPAN class=3Dcfun>index</SPAN>(text, '\n')) =3D '\<SPAN =
class=3Dcval>0</SPAN>';
        <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>( (err =
=3D <SPAN class=3Dcfun>regexec</SPAN>(&amp;myre, text, <SPAN =
class=3Dcval>0</SPAN>, <SPAN class=3Dctyp>NULL</SPAN>, <SPAN =
class=3Dcval>0</SPAN>)) =3D=3D <SPAN class=3Dcval>0</SPAN> ) <SPAN =
class=3Dcfun>puts</SPAN>(text);
        <SPAN class=3Dctyp>else</SPAN> <SPAN class=3Dctyp>if</SPAN><SPAN =
class=3Dcfun> </SPAN>( err !=3D REG_NOMATCH ) {
             <SPAN class=3Dccom>/* this is when errors have been =
encountered */</SPAN>
            <SPAN class=3Dcfun>regerror</SPAN>(err, &amp;myre, err_msg, =
MAX_ERR_LENGTH);
            <SPAN class=3Dctyp>return</SPAN> <SPAN =
class=3Dcval>2</SPAN>;
        }
    }=20

     <SPAN class=3Dccom>/* meaningless here. Useful in many other =
situations. */</SPAN>
    <SPAN class=3Dcfun>regfree</SPAN>(&amp;myre);
   =20
    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}</PRE></DIV><BR>You can download the original ascii source file with =
this link:=20
<A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/regexp/qegrep.c">qeg=
rep.c</A>.<BR>Compile=20
with: <TT>gcc --ansi --pedantic -Wall -o qegrep qegrep.c</TT><BR>Run =
with:=20
<TT>./qegrep 'Newstyle Regular Expression'&lt; textfile2scan</TT> or =
<TT>echo=20
"string2scan" | ./qegrep 'Newstyle Regular Expression'</TT> </DIV><BR>
<HR>
<A name=3Dcmdline>
<H3>Parsing the command line</H3></A>
<DIV class=3Dref_funcs>
<UL>
  <LI>getopt(3)=20
  <LI>getopt_long(3) </LI></UL></DIV><BR>
<DIV class=3Dnotes><A name=3Dcmdline_notes><B>Notes:</B></A><BR>This =
hasn't to be=20
done manually but through the <TT>getopt()</TT> and =
<TT>getopt_long()</TT>=20
facilities. Both them process the command line in form of (option, =
argument)=20
pairs.<BR>The <TT>getopt()</TT> function is the simplest one. It parses =
<I>short=20
options</I> (i.e. like "<TT>-b -a -c -x option</TT>" or equivalently =
"<TT>-bcax=20
option</TT>"). The <TT>getopt_long()</TT> function parses <I>long =
options</I>=20
(i.e. like "<TT>--big-option --anotherone --check =
--extra=3Doption</TT>", case=20
sensitive!). Getopt_long also supports short options, and short-long =
options=20
aliasing too: it is a actually super-set of getopt, a more difficult =
one.<BR>The=20
concept behind the getopt* functions is easy. They are both buffered =
functions=20
(so they're not thread safe). They are given the array of command line=20
parameters (<TT>argc</TT> and <TT>argv</TT>). They walk the array =
looking for=20
any of the recognized options (a list specified by the programmer). When =
one is=20
encountered, they return a reference to it, and possibly another one to =
its=20
argument. The way they offer parsing is <I>reactive</I>: the programmer =
should=20
specify the operations to be done after each call returned, wrt the =
option=20
encountered.<BR>For <TT>getopt()</TT>, the list of known options is a =
simple=20
string like "<TT>abx:c</TT>". Every single character in the string is a =
known=20
option. A character followed by a colon requires an argument. The order =
isn't=20
regarded, but recommended in case of many options. Every time it's =
called,=20
<TT>getopt()</TT> returns the next option in argv if it's recognized, =
"?" if=20
it's not recognized, or "-1" if no more options have been found =
(exhaustion).=20
Several global variables provided by an header file, the <TT>opt</TT>* =
vars, are=20
set for carrying more info about the option. <TT>optopt</TT> points out =
the=20
index of the option in *argv, and <TT>optarg</TT> points to the string =
which is=20
argument of the current option, if any (unspecified otherwise).<BR>For=20
<TT>getopt_long()</TT>, the list of recognized options is still the =
option=20
string as formerly, plus a support array, whose elements are each a =
structure=20
describing an option: (name, has_argument, short_name_or_val). In the =
latter,=20
<TT>name</TT> and <TT>has_argument</TT> are intuitive;=20
<TT>short_name_or_val</TT> can be set to a recognized <I>short</I> =
option (an=20
short-long aliasing will then occur), or to an arbitrary value to which =
set a=20
memory location (see summary and examples below for details).=20
<TT>getopt_long()</TT> return value is like <TT>getopt()</TT>, but 0 is =
returned=20
when a long option is recognized.<BR>Some automatic debugging is =
provided by=20
these functions. They autonomously warn the user about missing arguments =
and=20
unrecognized options. This default can be set off by setting to 0 the=20
<TT>opterr</TT> global variable. In this case the return value is used =
to=20
inspect what error have been found, if any: "?" for unknown option, ":" =
for=20
missing argument.</DIV><BR>
<DIV class=3Dsummary><A name=3Dtasks_summary><B>Summary:</B><BR>
<UL>
  <LI>what you have to #include: <TT>getopt.h</TT>=20
  <LI>global variables and types used: <PRE>    extern char *optarg;
    extern int opterr;
    extern int optind;
    /* and others ... */

    struct option {     /* only for getopt_long */
        const char *name;
        int has_arg;
        int *flag;      /* not null =3D&gt; val takes the value of =
what's pointed by it */
        int val;
    }</PRE>
  <LI>functions:<BR>
  <OL>
    <LI><TT>int <B>getopt</B>(int <B>argc</B>, const char =
<B>*argv[]</B>, const=20
    char <B>*optstring</B>)</TT><BR>parses short options. <TT>argc</TT> =
and=20
    <TT>argv</TT> are self explaining. <TT>optstring</TT> is the list of =

    recognized options, one character per option and colons for =
arguments, as=20
    explained above in Notes. Each call returns the option recognized, =
"?" if=20
    the option isn't recognized, or "-1" when option string is =
exhausted, and=20
    sets several <TT>opt</TT>* variables including <TT>optarg</TT> =
(eventually=20
    points to the argument string for the option), <TT>optopt</TT> =
(index of the=20
    last option recognized in <TT>argv</TT>), and <TT>opterr</TT> =
(whether=20
    automatic error prompting is enabled to the end user).=20
    <LI><TT>int <B>getopt_long</B>(int <B>argc</B>, const char =
<B>*argv[]</B>,=20
    const char <B>*optstring</B>, struct option <B>options[]</B>, int=20
    <B>*index</B>)</TT><BR>parses long options. <TT>argc</TT> and =
<TT>argv</TT>=20
    are self explaining. <TT>optstring</TT> is the list of the "short" =
options=20
    recognized, one character per option and colons for arguments, as =
explained=20
    above in Notes. <TT>options</TT> is an array of option structures =
for "long"=20
    options, whose last element must be 0 filled (see example =
2).<BR>There isn't=20
    any restriction for the relation occurring between the sets of long =
and=20
    short options. <TT>index</TT> is typically NULL; otherwise, the =
variable it=20
    points is set to the index of the long option recognized in the=20
    <TT>option[]</TT> array.<BR>Returns -1 on errors, 0 when only-long =
options=20
    are recognized, and the option character when short or short-long =
aliased=20
    options (optstring ones, those without an entry in the option array =
and=20
    those whose entry has flag set to NULL). </LI></OL></LI></UL></DIV>
<DIV class=3Dexamples><A name=3Dcmdline_examples><B>Examples:</B><BR>1) =
A simple=20
program that parses the command line option the classic way. Recognizes =
and=20
handles both argument-less and -ful options, and is sensible to option =
repeated.=20
Try executing without options, with repeated options (e.g. "-a -b -a") =
and=20
with/without arguments for "-x".=20
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  getopt-short.c
 * =20
 *  Parsing short-options command lines with getopt.
 *
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on 07/08/05.
 *  Original source file available on =
http://mij.oltrelinux.com/devel/unixprg/
 *
 */</SPAN>


<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
</SPAN>
<SPAN class=3Dcpdr>#define OPT_NUM     </SPAN><SPAN =
class=3Dcval>4</SPAN><SPAN class=3Dcpdr>       /* a, b, c and x (h is =
not relevant here) */
</SPAN>

<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>(<SPAN =
class=3Dctyp>int</SPAN> argc, <SPAN class=3Dctyp>char</SPAN> *argv[]) {
    <SPAN class=3Dctyp>int</SPAN> want_opt[OPT_NUM];     <SPAN =
class=3Dccom>/* want option? */</SPAN>
    <SPAN class=3Dctyp>char</SPAN> ch;                   <SPAN =
class=3Dccom>/* service variables */</SPAN>
    <SPAN class=3Dctyp>int</SPAN> i;
    <SPAN class=3Dctyp>char</SPAN> *my_argument;
   =20
   =20
    <SPAN class=3Dccom>/* init want_opt array */</SPAN>
    <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(i =3D <SPAN =
class=3Dcval>0</SPAN>; i &lt; OPT_NUM; i++)
       want_opt[i] =3D <SPAN class=3Dcval>0</SPAN>;

    <SPAN class=3Dccom>/* optstring: a, b, c, h; and x taking an =
argument */</SPAN>
    <SPAN class=3Dctyp>while</SPAN><SPAN class=3Dcfun> </SPAN>((ch =3D =
<SPAN class=3Dcfun>getopt</SPAN>(argc, argv, <SPAN =
class=3Dcstr>"abchx:"</SPAN>)) !=3D -<SPAN class=3Dcval>1</SPAN>) {     =
<SPAN class=3Dccom>/* getopt() iterates over argv[] */</SPAN>
        <SPAN class=3Dctyp>switch</SPAN><SPAN class=3Dcfun> </SPAN>(ch) =
{       <SPAN class=3Dccom>/* what getopt() returned */</SPAN>
            <SPAN class=3Dctyp>case</SPAN> <SPAN =
class=3Dcval>'a'</SPAN>:       <SPAN class=3Dccom>/* a has been =
recognized (possibly for the second or more time) */</SPAN>
                want_opt[<SPAN class=3Dcval>0</SPAN>] =3D want_opt[<SPAN =
class=3Dcval>0</SPAN>] + <SPAN class=3Dcval>1</SPAN>;     <SPAN =
class=3Dccom>/* remember about a */</SPAN>
                <SPAN class=3Dctyp>break</SPAN>;
            <SPAN class=3Dctyp>case</SPAN> <SPAN =
class=3Dcval>'b'</SPAN>:       <SPAN class=3Dccom>/* b */</SPAN>
                want_opt[<SPAN class=3Dcval>1</SPAN>]++;
                <SPAN class=3Dctyp>break</SPAN>;
            <SPAN class=3Dctyp>case</SPAN> <SPAN =
class=3Dcval>'c'</SPAN>:
                want_opt[<SPAN class=3Dcval>2</SPAN>]++;
                <SPAN class=3Dctyp>break</SPAN>;
            <SPAN class=3Dctyp>case</SPAN> <SPAN =
class=3Dcval>'x'</SPAN>:
                want_opt[<SPAN class=3Dcval>3</SPAN>]++;
                my_argument =3D optarg;   <SPAN class=3Dccom>/* preserve =
the pointer to x' argument */</SPAN>
                <SPAN class=3Dctyp>break</SPAN>;
            <SPAN class=3Dctyp>case</SPAN> <SPAN =
class=3Dcval>'h'</SPAN>:   <SPAN class=3Dccom>/* want help */</SPAN>
            <SPAN class=3Dctyp>default</SPAN>:
                <SPAN class=3Dccom>/* no options recognized: print =
options summary */</SPAN>
                <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Usage:\n%s [-a] [-b] [-c] [-h] [-x]\n"</SPAN>, argv[<SPAN =
class=3Dcval>0</SPAN>]);
               =20
                <SPAN class=3Dccom>/* typically here:=20
                exit(EXIT_FAILURE);
                */</SPAN>
        }
    }
   =20
    <SPAN class=3Dccom>/* print out results */</SPAN>
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"You =
requested:\n"</SPAN>);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> =
</SPAN>(want_opt[<SPAN class=3Dcval>0</SPAN>]) <SPAN =
class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"a [%d]\n"</SPAN>, =
want_opt[<SPAN class=3Dcval>0</SPAN>]);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> =
</SPAN>(want_opt[<SPAN class=3Dcval>1</SPAN>]) <SPAN =
class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"b [%d]\n"</SPAN>, =
want_opt[<SPAN class=3Dcval>1</SPAN>]);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> =
</SPAN>(want_opt[<SPAN class=3Dcval>2</SPAN>]) <SPAN =
class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"c [%d]\n"</SPAN>, =
want_opt[<SPAN class=3Dcval>2</SPAN>]);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> =
</SPAN>(want_opt[<SPAN class=3Dcval>3</SPAN>]) <SPAN =
class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"x [%d]: %s"</SPAN>, =
want_opt[<SPAN class=3Dcval>3</SPAN>], my_argument);  <SPAN =
class=3Dccom>/* but only the last one rests */</SPAN>
=20
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"\n"</SPAN>);
    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}
</PRE></DIV><BR>You can download the original ascii source file with =
this link:=20
<A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/cmdline/1/getopt-sho=
rt.c">getopt-short.c</A>.<BR>Compile=20
with: <TT>gcc --ansi --pedantic -Wall -o getopt-short =
getopt-short.c</TT> , or=20
via the makefile in the package.<BR>Run with: <TT>./getopt-short -a -r =
-b -x -a=20
-x foo -x</TT><BR>
<HR>
2) Parsing long options. This exemplifies the long-short option =
aliasing, and=20
how to handle long options without a short counterpart.=20
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  getopt-long.c
 * =20
 *  Parsing long-option command lines with getopt.
 *
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on 11/08/05.
 *  Original source file available on =
http://mij.oltrelinux.com/devel/unixprg/
 *
 */</SPAN>


<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
</SPAN><SPAN class=3Dccom>/* for getopt_long() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;getopt.h&gt;
</SPAN>

<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>(<SPAN =
class=3Dctyp>int</SPAN> argc, <SPAN class=3Dctyp>char</SPAN> *argv[]) {
    <SPAN class=3Dctyp>char</SPAN> ch;                   <SPAN =
class=3Dccom>/* service variables */</SPAN>
    <SPAN class=3Dctyp>int</SPAN> long_opt_index =3D <SPAN =
class=3Dcval>0</SPAN>;
    <SPAN class=3Dctyp>int</SPAN> longval;
    <SPAN class=3Dctyp>char</SPAN> *my_argument;
    <SPAN class=3Dctyp>struct</SPAN> option long_options[] =3D {        =
<SPAN class=3Dccom>/* long options array. Items are all caSe SensiTivE! =
*/</SPAN>
        { <SPAN class=3Dcstr>"add"</SPAN>, <SPAN class=3Dcval>0</SPAN>, =
<SPAN class=3Dctyp>NULL</SPAN>, <SPAN class=3Dcval>'a'</SPAN>   },      =
<SPAN class=3Dccom>/* --add or -a  */</SPAN>
        { <SPAN class=3Dcstr>"back"</SPAN>, <SPAN class=3Dcval>0</SPAN>, =
<SPAN class=3Dctyp>NULL</SPAN>, <SPAN class=3Dcval>'b'</SPAN>  },      =
<SPAN class=3Dccom>/* --back or -b */</SPAN>
        { <SPAN class=3Dcstr>"check"</SPAN>, <SPAN =
class=3Dcval>0</SPAN>, &amp;longval, <SPAN class=3Dcval>'c'</SPAN> },  =
<SPAN class=3Dccom>/* return 'c', or return 0 and set longval to 'c' if =
"check" is parsed */</SPAN>
        { <SPAN class=3Dcstr>"extra"</SPAN>, <SPAN =
class=3Dcval>1</SPAN>, &amp;longval, <SPAN class=3Dcval>'x'</SPAN> },
        { <SPAN class=3Dcval>0</SPAN>,    <SPAN class=3Dcval>0</SPAN>,   =
 <SPAN class=3Dcval>0</SPAN>,    <SPAN class=3Dcval>0</SPAN>   }       =
<SPAN class=3Dccom>/* terminating -0 item */</SPAN>
    };
   =20
   =20
    <SPAN class=3Dctyp>while</SPAN><SPAN class=3Dcfun> </SPAN>((ch =3D =
<SPAN class=3Dcfun>getopt_long</SPAN>(argc, argv, <SPAN =
class=3Dcstr>"abchx:"</SPAN>, long_options, &amp;long_opt_index)) !=3D =
-<SPAN class=3Dcval>1</SPAN>) {
       <SPAN class=3Dctyp>switch</SPAN><SPAN class=3Dcfun> </SPAN>(ch) {
           <SPAN class=3Dctyp>case</SPAN> <SPAN class=3Dcval>'a'</SPAN>: =
  <SPAN class=3Dccom>/* long_opt_index does not make sense for these =
*/</SPAN>
               <SPAN class=3Dccom>/* 'a' and '--add' are confused =
(aliased) */</SPAN>
               <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Option a, or --add.\n"</SPAN>);
               <SPAN class=3Dctyp>break</SPAN>;
           <SPAN class=3Dctyp>case</SPAN> <SPAN class=3Dcval>'b'</SPAN>:
               <SPAN class=3Dccom>/* 'b' and '--back' are confused =
(aliased) */</SPAN>
               <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Option b, or --back.\n"</SPAN>);
               <SPAN class=3Dctyp>break</SPAN>;
           <SPAN class=3Dctyp>case</SPAN> <SPAN class=3Dcval>'c'</SPAN>:
               <SPAN class=3Dccom>/* 'c' and '--check' are =
distinguished, but handled the same way */</SPAN>
               <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Option c, not --check.\n"</SPAN>);
               <SPAN class=3Dctyp>break</SPAN>;
           <SPAN class=3Dctyp>case</SPAN> <SPAN class=3Dcval>'x'</SPAN>:
               my_argument =3D optarg;
               <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Option x, not --extra. Argument %s.\n"</SPAN>, =
my_argument);
               <SPAN class=3Dctyp>break</SPAN>;
           <SPAN class=3Dctyp>case</SPAN> <SPAN class=3Dcval>0</SPAN>:   =
  <SPAN class=3Dccom>/* this is returned for long options with =
option[i].flag set (not NULL). */</SPAN>
                       <SPAN class=3Dccom>/* the flag itself will point =
out the option recognized, and long_opt_index is now relevant */</SPAN>
               <SPAN class=3Dctyp>switch</SPAN><SPAN class=3Dcfun> =
</SPAN>(longval) {
                   <SPAN class=3Dctyp>case</SPAN> <SPAN =
class=3Dcval>'c'</SPAN>:
                       <SPAN class=3Dccom>/* '--check' is managed here =
*/</SPAN>
                       <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Option --check, not -c (Array index: %d).\n"</SPAN>, =
long_opt_index);
                       <SPAN class=3Dctyp>break</SPAN>;
                   <SPAN class=3Dctyp>case</SPAN> <SPAN =
class=3Dcval>'x'</SPAN>:
                       <SPAN class=3Dccom>/* '--extra' is managed here =
*/</SPAN>
                       my_argument =3D optarg;
                       <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Option --extra, not -x (Array index: %d). Argument: =
%s.\n"</SPAN>, long_opt_index, my_argument);
                       <SPAN class=3Dctyp>break</SPAN>;
                   <SPAN class=3Dccom>/* there's no default here =
*/</SPAN>
               }
               <SPAN class=3Dctyp>break</SPAN>;
           <SPAN class=3Dctyp>case</SPAN> <SPAN class=3Dcval>'h'</SPAN>: =
  <SPAN class=3Dccom>/* mind that h is not described in the long option =
list */</SPAN>
               <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Usage: getopt-long [-a or --add] [-b or --back] [-c or =
--check] [-x or --extra]\n"</SPAN>);
               <SPAN class=3Dctyp>break</SPAN>;
           <SPAN class=3Dctyp>default</SPAN>:
               <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"You, =
lamah!\n"</SPAN>);
       }
    }
   =20
    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}
</PRE></DIV><BR>You can download the original ascii source file with =
this link:=20
<A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/cmdline/2/getopt-lon=
g.c">getopt-long.c</A>.<BR>Compile=20
with: <TT>gcc --ansi --pedantic -Wall -o getopt-long getopt-long.c</TT> =
, or via=20
the makefile in the package.<BR>Run with: <TT>./getopt-long -a --foobar =
--back=20
-x foo -b --check</TT>. </DIV>
<HR>
<A name=3Dtasks>
<H3>Tasks, fork(), wait() and waitpid()</H3></A>
<DIV class=3Dref_funcs>
<UL>
  <LI>fork(2)=20
  <LI>wait(2)=20
  <LI>waitpid(2)=20
  <LI>wait4(2) </LI></UL></DIV><BR>
<DIV class=3Dnotes><A name=3Dtasks_notes><B>Notes:</B></A><BR>A task is =
an=20
independent flow of instructions associated with a memory space and a =
private=20
context. You can clone a task into another one which will consequently =
run=20
concurrently and, once again, independently to it parent. The terms =
"parent",=20
"child", "grandfather" etc. are common for describing the hierarchical=20
relationship occurring between processes.<BR>Immediately after the fork, =
the=20
parent and the child are identical for both the code, the data and the =
context.=20
They can modify everything in their environment independently because =
their=20
contexts are separate. Since the code segment is identical, they will =
also run=20
the same instructions just after the fork. Looking at the return value =
of the=20
forking function is the only way to distinguish who's who. The parent is =

returned the Process ID of the child, whereas the child always gets the =
value=20
"0".<BR>The way to make this whole mechanism useful is actually to place =
a=20
branch just after the fork and decide what to do depending on who is the =
parent=20
and who is the child. The most common example to describe when tasks =
come useful=20
is a server accepting connections. You can run a process that listens =
for=20
incoming connections, and forks to a new child every time a new one =
occurs,=20
delegating it to serve the client. This design is cleaner than creating =
a=20
monolithic process which does everything itself.<BR>POSIX defines =
<I>pid_t=20
fork(void)</I> as function to fork a process. The fork() primitive can =
fail, for=20
example, when the total number of concurrent processes allowed by the OS =
has=20
been over-gone, or if some resource got exhausted. In this case no =
children are=20
produced.<BR>An important point to get is that nothing is said about =
which=20
between the parent or the child executes first right after fork() =
returns. Well=20
written code requires this is taken into account. If you postulate =
something=20
about that, you're writing unreliable code.<BR>Being processes, children =
can=20
terminate and return exit values. The <TT>wait()</TT> function lets the =
parent=20
fetch this value. It blocks the calling process until the first child=20
terminates; then, it returns the pid of the child and stores its exit =
status.=20
When a child terminates, the OS signals its parent with a SIGCHLD. When =
the=20
parent produced several children and one particular is expected to =
terminate,=20
the <TT>waitpid()</TT> function is to be used. Waitpid can also be =
instructed=20
not to be blocking, thereby it is used frequently in place of =
<TT>wait()</TT>=20
too. The SIGCHLD signal can also be bound to a "purging" wait() function =
for=20
skipping zombies accumulation.<BR>If a process terminates before any of =
its=20
children, the process with PID 1 (init(8)) receives the paternity of=20
them.<BR></DIV><BR>
<DIV class=3Dsummary><A name=3Dtasks_summary><B>Summary:</B><BR>
<UL>
  <LI>what you have to #include: <TT>sys/types.h</TT>, =
<TT>unistd.h</TT>,=20
  <TT>sys/wait.h</TT>=20
  <LI>types used: <TT>pid_t</TT> for identifying processes via PID=20
  <LI>functions:=20
  <OL>
    <LI><TT>pid_t <B>fork</B>(void)</TT><BR>The caller process creates a =
clone=20
    of itself which will run independently after the call. The caller is =

    returned the pid of the child. The child is returned 0. On errors=20
    <TT>fork()</TT> returns -1 without creating any child, and =
<TT>errno</TT> is=20
    set properly.=20
    <LI><TT>pid_t <B>wait</B>(int *status)</TT><BR>blocks until one of =
the=20
    children exits, stores its exit status in <TT>status</TT> and =
returns its=20
    pid, or -1 (setting <TT>errno</TT>) if errors happened.=20
    <LI><TT>pid_t <B>waitpid</B>(pid_t wpid, int *status, int=20
    options)</TT><BR>Does the same as <TT>wait()</TT>, but waiting for a =

    specific child identified by <TT>wpid</TT>. When <TT>wpid</TT> is =
-1, it=20
    waits for any children the same way <TT>wait()</TT> does. The=20
    <TT>options</TT> argument can be used to drive the behaviour of the=20
    function. The most commonly used option is WNOHANG, whose meaning is =
"do not=20
    wait, just check and exit if no children terminated". The function =
returns=20
    the pid of the child awaited, 0 if WNOHANG has been requested and =
the queue=20
    of terminated children is empty, -1 setting <TT>errno</TT> on =
errors.=20
    <LI><TT>pid_t <B>wait4</B>(pid_t wpid, int *status, int options, =
struct=20
    rusage *rusage)</TT><BR>this is the most powerful function for =
getting child=20
    processes informations. It acts pretty the same way as =
<TT>waitpid()</TT>,=20
    but fills the <TT>rusage</TT> struct with statistics about the =
process=20
    awaited such as resources utilization and pages reclaimed.=20
    <LI><TT>pid_t <B>getpid</B>(void)</TT><BR>Returns the Process ID of =
the=20
    caller. Always successful.=20
    <LI><TT>pid_t <B>getppid</B>(void)</TT><BR>Returns the parent's =
Process ID=20
    of the caller. Always successful. </LI></OL>
  <LI>macros (for <TT>waitpid()</TT> and <TT>wait4()</TT>):=20
  <OL>
    <LI><TT><B>WIFEXITED</B>(status)</TT><BR>returns true (non-zero) if=20
    <TT>status</TT> denotes a normal process exit status=20
    <LI><TT><B>WIFSIGNALED</B>(status)</TT><BR>returns true if the =
process=20
    terminated after receiving a signal=20
    <LI><TT><B>WIFSTOPPED</B>(status)</TT><BR>returns true if the =
process is not=20
    running but has been stopped, and can be restarted=20
    <LI><TT><B>WEXITSTATUS</B>(status)</TT><BR>returns the process exit =
status=20
    information carried by <TT>status</TT>=20
    <LI><TT><B>WTERMSIG</B>(status)</TT><BR>returns the number of the =
signal=20
    which made the process terminate. If the process terminated =
normally, this=20
    is meaningless.=20
    <LI><TT><B>WSTOPSIG</B>(status)</TT><BR>returns the number of the =
signal=20
    which put the process into stop. </LI></OL></LI></UL></DIV><BR>
<DIV name=3D"examples"><A name=3Dtasks_examples><B>Examples:</B><BR>1) =
Practicing=20
with paternities, pids, exit statuses. The process forks to a child, =
then waits=20
for someone to terminate. The child forks into another child, and =
wait(pid) for=20
it to terminate. This latter child forks into another child, doesn't =
expect for=20
anyone and terminates.=20
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  procsmess.c
 *
 *  A completely meaningless example for tasks.
 *  The parent process forks, then wait() for output
 *  the exit status of who exited. The child forks
 *  and does the same with waitpid(). The grandchild
 *  finally forks and suddendly terminate.
 *
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on Wed Dec 31 2003.
 *  Original source file available on =
http://mij.oltrelinux.com/devel/unixprg/
 */</SPAN>

 <SPAN class=3Dccom>/* for printf() and perror() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
</SPAN> <SPAN class=3Dccom>/* for fork() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
</SPAN> <SPAN class=3Dccom>/* for wait*() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;sys/wait.h&gt;
</SPAN>
<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>() {
    pid_t mypid, childpid;
    <SPAN class=3Dctyp>int</SPAN> status;
   =20
     <SPAN class=3Dccom>/* what's our pid? */</SPAN>
    mypid =3D <SPAN class=3Dcfun>getpid</SPAN>();
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Hi. I'm the =
parent process. My pid is %d.\n"</SPAN>, mypid);
   =20
     <SPAN class=3Dccom>/* create the child */</SPAN>
    childpid =3D <SPAN class=3Dcfun>fork</SPAN>();
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>( childpid =
=3D=3D -<SPAN class=3Dcval>1</SPAN> ) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"Cannot =
proceed. fork() error"</SPAN>);
        <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>1</SPAN>;
    }
   =20
   =20
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(childpid  =
=3D=3D <SPAN class=3Dcval>0</SPAN>) {
         <SPAN class=3Dccom>/* then we're the child process "Child 1" =
*/</SPAN>
        <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Child 1: I =
inherited my parent's pid as %d.\n"</SPAN>, mypid);
       =20
         <SPAN class=3Dccom>/* get our pid: notice that this doesn't =
touch the value of parent's "mypid" value */</SPAN>
        mypid =3D <SPAN class=3Dcfun>getpid</SPAN>();
        <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Child 1: =
getppid() tells my parent is %d. My own pid instead is %d.\n"</SPAN>, =
<SPAN class=3Dcfun>getppid</SPAN>(), mypid);
       =20
       =20
         <SPAN class=3Dccom>/* forks another child */</SPAN>
        childpid =3D <SPAN class=3Dcfun>fork</SPAN>();
        <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>( =
childpid =3D=3D -<SPAN class=3Dcval>1</SPAN> ) {
            <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"Cannot =
proceed. fork() error"</SPAN>);
            <SPAN class=3Dctyp>return</SPAN> <SPAN =
class=3Dcval>1</SPAN>;
        }
       =20
        <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(childpid =
=3D=3D <SPAN class=3Dcval>0</SPAN>) {
             <SPAN class=3Dccom>/* this is the child of the first child, =
thus "Child 2" */</SPAN>
            <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Child =
2: I hinerited my parent's PID as %d.\n"</SPAN>, mypid);
           =20
            mypid =3D <SPAN class=3Dcfun>getpid</SPAN>();
            <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Child =
2: getppid() tells my parent is %d. My own pid instead is %d.\n"</SPAN>, =
<SPAN class=3Dcfun>getppid</SPAN>(), mypid);
           =20
            childpid =3D <SPAN class=3Dcfun>fork</SPAN>();
            <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>( =
childpid =3D=3D -<SPAN class=3Dcval>1</SPAN> ) {
                <SPAN class=3Dcfun>perror</SPAN>(<SPAN =
class=3Dcstr>"Cannot proceed. fork() error"</SPAN>);
                <SPAN class=3Dctyp>return</SPAN> <SPAN =
class=3Dcval>1</SPAN>;
            }
           =20
            <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> =
</SPAN>(childpid =3D=3D <SPAN class=3Dcval>0</SPAN>) {
                 <SPAN class=3Dccom>/* "Child 3" sleeps 30 seconds then =
terminates 12, hopefully before its parent "Child 2" */</SPAN>
                <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Child 3: I hinerited my parent's PID as %d.\n"</SPAN>, =
mypid);
               =20
                mypid =3D <SPAN class=3Dcfun>getpid</SPAN>();
                <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Child 3: getppid() tells my parent is %d. My own pid =
instead is %d.\n"</SPAN>, <SPAN class=3Dcfun>getppid</SPAN>(), mypid);
               =20
                <SPAN class=3Dcfun>sleep</SPAN>(<SPAN =
class=3Dcval>30</SPAN>);
                <SPAN class=3Dctyp>return</SPAN> <SPAN =
class=3Dcval>12</SPAN>;
            } <SPAN class=3Dctyp>else</SPAN>   <SPAN class=3Dccom>/* the =
parent "Child 2" suddendly returns 15 */</SPAN>  <SPAN =
class=3Dctyp>return</SPAN> <SPAN class=3Dcval>15</SPAN>;
        } <SPAN class=3Dctyp>else</SPAN> {
             <SPAN class=3Dccom>/* this is still "Child 1", which waits =
for its child to exit */</SPAN>
            <SPAN class=3Dctyp>while</SPAN><SPAN class=3Dcfun> </SPAN>( =
<SPAN class=3Dcfun>waitpid</SPAN>(childpid, &amp;status, WNOHANG) =3D=3D =
<SPAN class=3Dcval>0</SPAN> ) <SPAN class=3Dcfun>sleep</SPAN>(<SPAN =
class=3Dcval>1</SPAN>);
           =20
            <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>( =
<SPAN class=3Dcfun>WIFEXITED</SPAN>(status) ) <SPAN =
class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Child1: Child 2 exited =
with exit status %d.\n"</SPAN>, <SPAN =
class=3Dcfun>WEXITSTATUS</SPAN>(status));
            <SPAN class=3Dctyp>else</SPAN> <SPAN =
class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Child 1: child has not =
terminated correctly.\n"</SPAN>);
        }
    } <SPAN class=3Dctyp>else</SPAN> {
         <SPAN class=3Dccom>/* then we're the parent process, "Parent" =
*/</SPAN>
        <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Parent: =
fork() went ok. My child's PID is %d\n"</SPAN>, childpid);
        =20
         <SPAN class=3Dccom>/* wait for the child to terminate and =
report about that */</SPAN>
        <SPAN class=3Dcfun>wait</SPAN>(&amp;status);
       =20
        <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>( <SPAN =
class=3Dcfun>WIFEXITED</SPAN>(status) ) <SPAN =
class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Parent: child has exited =
with status %d.\n"</SPAN>, <SPAN =
class=3Dcfun>WEXITSTATUS</SPAN>(status));
        <SPAN class=3Dctyp>else</SPAN> <SPAN =
class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Parent: child has not =
terminated normally.\n"</SPAN>);
    }
   =20
    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}
</PRE></DIV><BR>You can download the original ascii source file with =
this link:=20
<A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/fork/1/procsmess.c">=
procsmess.c</A>.<BR>Compile=20
with: <TT>gcc --ansi --pedantic -Wall -o procsmess =
procsmess.c</TT><BR>Run with:=20
<TT>./procsmess</TT><BR><BR>
<HR>
2) Handling lots of children. The parent loops forking. Each child does =
nothing=20
and suddenly terminates. The parent cycles on waitpid to keep the exit =
statuses=20
queue the shortest it can. Just put a "sleep(1);" into children to see a =
memory=20
exhaustion or MAXPROCS reached. A desktop user will never see such an =
occurrence=20
besides bugs, while servers can occasionally run into problems on this =
topic.=20
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  forkvswaitpid.c
 * =20
 *  The parent loops forking and waiting.
 *  Notice the behaviour of both the post-fork()
 *  and post-waitpid() messages.
 *
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on Wed Dec 31 2003.
 *  Original source file available on =
http://mij.oltrelinux.com/devel/unixprg/
 */</SPAN>

<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
</SPAN>
<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>() {
    pid_t pid;
    <SPAN class=3Dctyp>int</SPAN> status;
   =20
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Hi. Your OS =
would get a bit busy right now. Please kill pressing ctrl+C\n"</SPAN>);
   =20
    <SPAN class=3Dctyp>while</SPAN><SPAN class=3Dcfun> </SPAN>(<SPAN =
class=3Dcval>1</SPAN>) {
        pid =3D <SPAN class=3Dcfun>fork</SPAN>();
       =20
        <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>( pid =
=3D=3D -<SPAN class=3Dcval>1</SPAN> ) {
            <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"Error =
on fork()"</SPAN>);
            <SPAN class=3Dctyp>return</SPAN> <SPAN =
class=3Dcval>1</SPAN>;
        }
       =20
        <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(pid =
=3D=3D <SPAN class=3Dcval>0</SPAN>) {
             <SPAN class=3Dccom>/* we're the child */</SPAN>
            <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"One =
more child born.\n"</SPAN>);
            <SPAN class=3Dctyp>return</SPAN> <SPAN =
class=3Dcval>0</SPAN>;
        } <SPAN class=3Dctyp>else</SPAN>
             <SPAN class=3Dccom>/* we're the parent and we want to purge =
the queue of childs exited */</SPAN>
            <SPAN class=3Dctyp>while</SPAN><SPAN class=3Dcfun> </SPAN>( =
<SPAN class=3Dcfun>waitpid</SPAN>(-<SPAN class=3Dcval>1</SPAN>, =
&amp;status, WNOHANG) &gt; <SPAN class=3Dcval>0</SPAN> ) <SPAN =
class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"One more child =
dead.\n"</SPAN>);
    }
   =20
    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}
</PRE></DIV><BR>You can download the original ascii source file with =
this link:=20
<A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/fork/2/forkvswaitpid=
.c">forkvswaitpid.c</A>.<BR>Compile=20
with: <TT>gcc --ansi --pedantic -Wall -o forkvswaitpid=20
forkvswaitpid.c</TT><BR>Run with: <TT>./forkvswaitpid</TT> </DIV>
<HR>
<A name=3Dthreads>
<H3>Threads</H3></A>
<DIV class=3Dref_funcs>
<UL>
  <LI>pthread(3)=20
  <LI>and any function it lists </LI></UL></DIV><BR>
<DIV class=3Dnotes><A name=3Dthreads_notes><B>Notes:</B></A><BR>Threads =
are=20
frequently reported as "alternatives to tasks". Since threads allow to =
satisfy a=20
wider set of requirements than tasks, it's not fair to talk about them =
in these=20
terms.<BR>A thread is an independent stream of instructions running =
inside the=20
scope of a process. A task can create several threads which will run=20
concurrently. Threads live in the same context of their caller. Since =
their=20
creation does not require the whole process context to be replicated in =
memory=20
(as in fork()), they are way faster than tasks. The same questioning =
about=20
context also plays for the lower scheduling overhead.<BR>Since threads =
aren't=20
independent of each other, they are also more difficult to use.<BR>From =
the=20
point of view of the developer, a thread is a function. The caller may =
thread=20
the function to make it executing concurrently with the main stream of=20
instructions. The function can access the whole context of the process =
it's=20
running inside, e.g. global vars, open files and other =
functions.<BR>Each=20
instance has its own stack record, then an autonomous local scope. =
Multiple=20
concurrent instances of a function will not share local variables =
then.<BR>The=20
real deal with threads is controlling overlaps and inconsistencies. =
Designing=20
threaded applications is difficult. You must take care of your own code, =
but you=20
must also take into account others' code. Libcalls you use must be =
thread-safe=20
as well as *your* functions. In order to write thread-safe code, you =
must design=20
thread-safe algorithms and involve thread-safe functions. Whether a =
library is=20
thread-safe or not is normally reported explicitly on its man pages or =
in its=20
source code.<BR><I>pthread</I>s are the standard thread API proposed by =
POSIX,=20
and implemented by most of the POSIX-compliance OSes.<BR>pthreads define =
a set=20
of functions that let the programmer handle threads in a simple manner. =
They're=20
partitioned into four main families depending on their goal: thread, =
attribute=20
objects, Mut(ual)Ex(clusion) and condition variable routines. This page =
will=20
just cover the first two families, the most commonly used. If you need =
to do=20
something from the other ones, then you don't just need to quickly carry =
out a=20
threaded program, and you might spend the time to carefully read the =
actual=20
manpages. </DIV><BR>
<DIV class=3Dsummary><A name=3Dthreads_summary><B>Summary</B></A><BR>
<UL>
  <LI>despite tasks, threads *do* share address-spaces with their caller =

  <LI>to write safe code using threads, thread-safeness of every =
function=20
  involved ist something you must make sure=20
  <LI>since threads share their context with the creator, a certain =
attention=20
  should be paid to possible side effects=20
  <LI>what you have to #include: <TT>pthread.h</TT>=20
  <LI>types used: <TT>pthread_t</TT>, <TT>pthread_attr_t</TT>=20
  <LI>thread functions (one more time: -partial-):=20
  <OL>
    <LI><TT>int <B>pthread_create</B>(pthread_t *thread, const =
pthread_attr_t=20
    *attr, void *(*start_routine)(void *), void *arg)</TT><BR>raises a =
thread=20
    executing the function <TT>start_routine</TT> (completely ignoring =
their=20
    arguments and return values). <TT>thread</TT> is set to the threadID =

    assigned. Thread's attributes can be disposed by properly setting=20
    <TT>attr</TT>, or let defaults by passing NULL. <TT>arg</TT> is the =
only way=20
    to pass arguments to the routine, always passed by reference and =
casted to=20
    <TT>void *</TT>, or NULL for no arguments. On success 0 is returned. =

    <LI><TT>void <B>pthread_exit</B>(void *value_ptr)</TT><BR>makes the =
calling=20
    thread terminate, offering <TT>value_ptr</TT> to who joins the =
exiting=20
    thread. (see below) In any thread except the one which runs =
<TT>main()</TT>,=20
    this is completely equivalent to what the <TT>return</TT> statement =
does.=20
    <LI><TT>pthread_t <B>pthread_self</B>(void)</TT><BR>returns the =
thread id.=20
    <LI><TT>int <B>pthread_join</B>(pthread_t thread, void=20
    **value_ptr)</TT><BR>suspends the calling stream of execution until=20
    <TT>thread</TT> terminates. <TT>thread</TT>'s return status made =
available=20
    by <TT>return</TT> of <TT>pthread_exit</TT> is stored in =
<TT>value_ptr</TT>.=20
    Returns 0 on success. Non-zero on failure=20
    <LI><TT>int <B>pthread_detach</B>(pthread_t thread)</TT><BR>sets=20
    <TT>thread</TT> non-joinable. When <TT>thread</TT> terminates, its =
return=20
    value will be ignored. Returns 0 on success, non-zero on failure. =
This does=20
    <I>not</I> put the target thread to termination.=20
    <LI><TT>int <B>pthread_cancel</B>(pthread_t thread)</TT><BR>cancels =
the=20
    target thread. The cancellation is done dependently on some =
attributes of=20
    <TT>thread</TT> itself. </LI></OL>
  <LI>attribute obj functions:=20
  <OL>
    <LI><TT>int <B>pthread_attr_init</B>(pthread_attr_t=20
    *attr)</TT><BR>initializes the attribute object <TT>attr</TT> with =
defaults=20
    thread attributes. These could then be customized with the functions =
below.=20
    <LI><TT>int <B>pthread_attr_setdetachstate</B>(pthread_attr_t *attr, =
int=20
    detachstate)</TT><BR>sets <TT>attr</TT>'s detach status to =
detachstate.=20
    Default is commonly non-detachable, but it's recommended to be =
explicit to=20
    write portable code.=20
    <LI><TT>int <B>pthread_attr_getdetachstate</B>(pthread_attr_t *attr, =
int=20
    *detachstate)</TT><BR>writes the detach status information contained =
in the=20
    thread attribute object <TT>attr</TT> into <TT>detachstate</TT>. 0 =
returned=20
    on success. Non-zero on error.=20
    <LI><TT>int <B>pthread_attr_destroy</B>(pthread_attr_t =
*attr)</TT><BR>frees=20
    the space used for the attribute object <TT>attr</TT>.=20
</LI></OL></LI></UL></DIV>
<DIV class=3Dexamples><A name=3Dthreads_examples><B>Examples:</B><BR>The =
following=20
examples are from "Using POSIX Threads: Programming with Pthreads" by =
Brad=20
nichols, Dick Buttlar, Jackie Farrell O'Reilly &amp; Associates, Inc. I =
find=20
they're quite complete, so I'm not going to spend time to write other =
ones.=20
Unfortunately they're not documented. I added a short description of =
their=20
behaviour on the top of their source code, and therein embedded some =
comment.=20
Maybe in the future i'll write something more complete and clear (and =
better=20
written) than them.<BR><BR>1) This shows out how to create and "join" =
threads.=20
"Joining" for threads is analogue to "waiting" for tasks.=20
<DIV class=3Dcsource><PRE><SPAN =
class=3Dccom>/********************************************************
 * An example source module to accompany...
 *
 * "Using POSIX Threads: Programming with Pthreads"
 *     by Brad nichols, Dick Buttlar, Jackie Farrell
 *     O'Reilly &amp; Associates, Inc.
 *
 ********************************************************
 * simple_threads.c
 *
 * Simple multi-threaded example.
 * Creates two threads. While doing different things, they
 * both access and modify variables with global scope.
 * Those vars have been tought to be modified this way, so
 * this is *not* an example of a thread side effect. If each
 * thread'd been accessing the same variable, they could create
 * such kind of problems.
 */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;pthread.h&gt;
</SPAN>
<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>do_one_thing</SPAN>(<SPAN class=3Dctyp>int</SPAN> *);       =
    <SPAN class=3Dccom>/* first function to thread */</SPAN>
<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>do_another_thing</SPAN>(<SPAN class=3Dctyp>int</SPAN> *);   =
    <SPAN class=3Dccom>/* second function to thread */</SPAN>
<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>do_wrap_up</SPAN>(<SPAN class=3Dctyp>int</SPAN>, <SPAN =
class=3Dctyp>int</SPAN>);          <SPAN class=3Dccom>/* after joining =
threads... */</SPAN>

<SPAN class=3Dctyp>int</SPAN> r1 =3D <SPAN class=3Dcval>0</SPAN>, r2 =3D =
<SPAN class=3Dcval>0</SPAN>;

<SPAN class=3Dctyp>extern</SPAN> <SPAN class=3Dctyp>int</SPAN>
<SPAN class=3Dcfun>main</SPAN>(<SPAN class=3Dctyp>void</SPAN>)
{
   <SPAN class=3Dccom>/* ids for the first and the second thread =
*/</SPAN>
  pthread_t thread1, thread2;
=20
   <SPAN class=3Dccom>/* creating the first thread. retval !=3D 0 means =
troubles */</SPAN>
  <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(<SPAN =
class=3Dcfun>pthread_create</SPAN>(&amp;thread1,=20
         <SPAN class=3Dctyp>NULL</SPAN>,
         (<SPAN class=3Dctyp>void</SPAN> *) do_one_thing,
         (<SPAN class=3Dctyp>void</SPAN> *) &amp;r1) !=3D <SPAN =
class=3Dcval>0</SPAN>)
    <SPAN class=3Dcfun>perror</SPAN>(<SPAN =
class=3Dcstr>"pthread_create"</SPAN>), <SPAN =
class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);=20
 =20
   <SPAN class=3Dccom>/* creating the first thread. retval !=3D 0 means =
troubles.
    * its argument is passed with a void * casting as requested
    * by pthread_create. The actual function expects an int. */</SPAN>
  <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(<SPAN =
class=3Dcfun>pthread_create</SPAN>(&amp;thread2,=20
         <SPAN class=3Dctyp>NULL</SPAN>,=20
         (<SPAN class=3Dctyp>void</SPAN> *) do_another_thing,
         (<SPAN class=3Dctyp>void</SPAN> *) &amp;r2) !=3D <SPAN =
class=3Dcval>0</SPAN>)
    <SPAN class=3Dcfun>perror</SPAN>(<SPAN =
class=3Dcstr>"pthread_create"</SPAN>), <SPAN =
class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);=20
 =20
   <SPAN class=3Dccom>/* waiting for the first thread to terminate.
    * Thread's return(/exit) value gets discarded. */</SPAN>
  <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(<SPAN =
class=3Dcfun>pthread_join</SPAN>(thread1, <SPAN =
class=3Dctyp>NULL</SPAN>) !=3D <SPAN class=3Dcval>0</SPAN>)
    <SPAN class=3Dcfun>perror</SPAN>(<SPAN =
class=3Dcstr>"pthread_join"</SPAN>),<SPAN class=3Dcfun>exit</SPAN>(<SPAN =
class=3Dcval>1</SPAN>);
=20
   <SPAN class=3Dccom>/* waiting for the second thread */</SPAN>
  <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(<SPAN =
class=3Dcfun>pthread_join</SPAN>(thread2, <SPAN =
class=3Dctyp>NULL</SPAN>) !=3D <SPAN class=3Dcval>0</SPAN>)
    <SPAN class=3Dcfun>perror</SPAN>(<SPAN =
class=3Dcstr>"pthread_join"</SPAN>),<SPAN class=3Dcfun>exit</SPAN>(<SPAN =
class=3Dcval>1</SPAN>);

  <SPAN class=3Dcfun>do_wrap_up</SPAN>(r1, r2);

  <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;=20
}

<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>do_one_thing</SPAN>(<SPAN class=3Dctyp>int</SPAN> =
*pnum_times)
{
  <SPAN class=3Dctyp>int</SPAN> i, j, x;
 =20
  <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(i =3D <SPAN =
class=3Dcval>0</SPAN>;  i &lt; <SPAN class=3Dcval>4</SPAN>; i++) {
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"doing one =
thing\n"</SPAN>);=20
    <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(j =3D <SPAN =
class=3Dcval>0</SPAN>; j &lt; <SPAN class=3Dcval>10000</SPAN>; j++) x =
=3D x + i;
    (*pnum_times)++;
  }

}

<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>do_another_thing</SPAN>(<SPAN class=3Dctyp>int</SPAN> =
*pnum_times)
{
  <SPAN class=3Dctyp>int</SPAN> i, j, x;
 =20
  <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(i =3D <SPAN =
class=3Dcval>0</SPAN>;  i &lt; <SPAN class=3Dcval>4</SPAN>; i++) {
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"doing another =
\n"</SPAN>);=20
    <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(j =3D <SPAN =
class=3Dcval>0</SPAN>; j &lt; <SPAN class=3Dcval>10000</SPAN>; j++) x =
=3D x + i;
    (*pnum_times)++;
  }

}

<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>do_wrap_up</SPAN>(<SPAN class=3Dctyp>int</SPAN> one_times, =
<SPAN class=3Dctyp>int</SPAN> another_times)
{
  <SPAN class=3Dctyp>int</SPAN> total;

  total =3D one_times + another_times;
  <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"All done, one =
thing %d, another %d for a total of %d\n"</SPAN>,
    one_times, another_times, total);
}
</PRE></DIV><BR>You can download the original ascii source file with =
this link:=20
<A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/threads/1/simple_thr=
eads.c">simple_threads.c</A>.<BR>Compile=20
with: <TT>gcc --pedantic -Wall -o simple_threads =
simple_threads.c</TT><BR>Run=20
with: <TT>./simple_threads</TT><BR><BR>
<HR>
2) A precious example on Mutual Exclusion.=20
<DIV class=3Dcsource><PRE><SPAN =
class=3Dccom>/********************************************************
 * An example source module to accompany...
 *
 * "Using POSIX Threads: Programming with Pthreads"
 *     by Brad nichols, Dick Buttlar, Jackie Farrell
 *     O'Reilly &amp; Associates, Inc.
 *
 ********************************************************
 * simple_mutex.c
 *
 * Simple multi-threaded example with a mutex lock.
 * Does the same as the example above (see the link below)
 * but with mutual exclusion. Any time a thread starts, it
 * request the thread lock. Just one thread is executing
 * anytime. The others must wait it to unlock before proceeding.
 * quickly comment out by Mij &lt;mij@bitchx.it&gt; for
 * http://mij.oltrelinux.com/devel/unixprg/
 *
 * (also modified a bit on the code itself for clarity and
 * expressiveness purposes)
 */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;pthread.h&gt;
</SPAN>
<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>do_one_thing</SPAN>(<SPAN class=3Dctyp>int</SPAN> *);       =
<SPAN class=3Dccom>/* first thread */</SPAN>
<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>do_another_thing</SPAN>(<SPAN class=3Dctyp>int</SPAN> *);   =
    <SPAN class=3Dccom>/* second thread */</SPAN>
<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>do_wrap_up</SPAN>(<SPAN class=3Dctyp>int</SPAN>, <SPAN =
class=3Dctyp>int</SPAN>);

<SPAN class=3Dctyp>int</SPAN> r1 =3D <SPAN class=3Dcval>0</SPAN>, r2 =3D =
<SPAN class=3Dcval>0</SPAN>, r3 =3D <SPAN class=3Dcval>0</SPAN>;
pthread_mutex_t r3_mutex=3DPTHREAD_MUTEX_INITIALIZER; <SPAN =
class=3Dccom>/* for mutex locking */</SPAN>

<SPAN class=3Dctyp>extern</SPAN> <SPAN class=3Dctyp>int</SPAN>
<SPAN class=3Dcfun>main</SPAN>(<SPAN class=3Dctyp>int</SPAN> argc, <SPAN =
class=3Dctyp>char</SPAN> **argv)
{
   <SPAN class=3Dccom>/* thread ids */</SPAN>
  pthread_t thread1, thread2;

  <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(argc &gt; =
<SPAN class=3Dcval>1</SPAN>)=20
    r3 =3D <SPAN class=3Dcfun>atoi</SPAN>(argv[<SPAN =
class=3Dcval>1</SPAN>]);

   <SPAN class=3Dccom>/* creating the first thread */</SPAN>
  <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(<SPAN =
class=3Dcfun>pthread_create</SPAN>(&amp;thread1,=20
         <SPAN class=3Dctyp>NULL</SPAN>,
         (<SPAN class=3Dctyp>void</SPAN> *) do_one_thing,
         (<SPAN class=3Dctyp>void</SPAN> *) &amp;r1) !=3D <SPAN =
class=3Dcval>0</SPAN>)
    <SPAN class=3Dcfun>perror</SPAN>(<SPAN =
class=3Dcstr>"pthread_create"</SPAN>),<SPAN =
class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);=20

   <SPAN class=3Dccom>/* creating the second thread */</SPAN>
  <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(<SPAN =
class=3Dcfun>pthread_create</SPAN>(&amp;thread2,=20
         <SPAN class=3Dctyp>NULL</SPAN>,=20
         (<SPAN class=3Dctyp>void</SPAN> *) do_another_thing,
         (<SPAN class=3Dctyp>void</SPAN> *) &amp;r2) !=3D <SPAN =
class=3Dcval>0</SPAN>)
    <SPAN class=3Dcfun>perror</SPAN>(<SPAN =
class=3Dcstr>"pthread_create"</SPAN>),<SPAN =
class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);=20
 =20
   <SPAN class=3Dccom>/* expecting the first thread to terminate =
*/</SPAN>
  <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(<SPAN =
class=3Dcfun>pthread_join</SPAN>(thread1, <SPAN =
class=3Dctyp>NULL</SPAN>) !=3D <SPAN class=3Dcval>0</SPAN>)
    <SPAN class=3Dcfun>perror</SPAN>(<SPAN =
class=3Dcstr>"pthread_join"</SPAN>), <SPAN =
class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
 =20
   <SPAN class=3Dccom>/* expecting the second thread to terminate =
*/</SPAN>
  <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(<SPAN =
class=3Dcfun>pthread_join</SPAN>(thread2, <SPAN =
class=3Dctyp>NULL</SPAN>) !=3D <SPAN class=3Dcval>0</SPAN>)
    <SPAN class=3Dcfun>perror</SPAN>(<SPAN =
class=3Dcstr>"pthread_join"</SPAN>), <SPAN =
class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);

  <SPAN class=3Dcfun>do_wrap_up</SPAN>(r1, r2);

  <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;=20
}

<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>do_one_thing</SPAN>(<SPAN class=3Dctyp>int</SPAN> =
*pnum_times)
{
  <SPAN class=3Dctyp>int</SPAN> i, j, x;
  pthread_t ti;

  ti =3D <SPAN class=3Dcfun>pthread_self</SPAN>();      <SPAN =
class=3Dccom>/* which's our id? */</SPAN>
  <SPAN class=3Dcfun>pthread_mutex_lock</SPAN>(&amp;r3_mutex);
   <SPAN class=3Dccom>/* this is the segment containing sensitive =
operations.
    * So we need to keep it alone from concurrency for safeness. =
*/</SPAN>
  <SPAN class=3Dctyp>if</SPAN>(r3 &gt; <SPAN class=3Dcval>0</SPAN>) {
    x =3D r3;
    r3--;
  } <SPAN class=3Dctyp>else</SPAN> {
    x =3D <SPAN class=3Dcval>1</SPAN>;
  }
   <SPAN class=3Dccom>/* sensitive code end */</SPAN>
  <SPAN class=3Dcfun>pthread_mutex_unlock</SPAN>(&amp;r3_mutex);=20

  <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(i =3D <SPAN =
class=3Dcval>0</SPAN>;  i &lt; <SPAN class=3Dcval>4</SPAN>; i++) {
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"doing one =
thing\n"</SPAN>);=20
      <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(j =3D =
<SPAN class=3Dcval>0</SPAN>; j &lt; <SPAN class=3Dcval>10000</SPAN>; =
j++) x =3D x + i;
      <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"thread %d: =
got x =3D %d\n"</SPAN>, (<SPAN class=3Dctyp>int</SPAN>)ti, x);
    (*pnum_times)++;
  }

}

<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>do_another_thing</SPAN>(<SPAN class=3Dctyp>int</SPAN> =
*pnum_times)
{
  <SPAN class=3Dctyp>int</SPAN> i, j, x;
  pthread_t ti;
   =20
  ti =3D <SPAN class=3Dcfun>pthread_self</SPAN>();
  <SPAN class=3Dcfun>pthread_mutex_lock</SPAN>(&amp;r3_mutex);
  <SPAN class=3Dctyp>if</SPAN>(r3 &gt; <SPAN class=3Dcval>0</SPAN>) {
        x =3D r3;
        r3--;
  } <SPAN class=3Dctyp>else</SPAN> {
        x =3D <SPAN class=3Dcval>1</SPAN>;
  }
  <SPAN class=3Dcfun>pthread_mutex_unlock</SPAN>(&amp;r3_mutex);

  <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(i =3D <SPAN =
class=3Dcval>0</SPAN>;  i &lt; <SPAN class=3Dcval>4</SPAN>; i++) {
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"doing another =
\n"</SPAN>);=20
    <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(j =3D <SPAN =
class=3Dcval>0</SPAN>; j &lt; <SPAN class=3Dcval>10000</SPAN>; j++) x =
=3D x + i;
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"thread %d: got =
x =3D %d\n"</SPAN>, (<SPAN class=3Dctyp>int</SPAN>)ti, x);
    (*pnum_times)++;
  }

}

<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>do_wrap_up</SPAN>(<SPAN class=3Dctyp>int</SPAN> one_times, =
<SPAN class=3Dctyp>int</SPAN> another_times)
{
  <SPAN class=3Dctyp>int</SPAN> total;

  total =3D one_times + another_times;
  <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"All done, one =
thing %d, another %d for a total of %d\n"</SPAN>,
    one_times, another_times, total);
}
</PRE></DIV><BR>You can download the original ascii source file with =
this link:=20
<A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/threads/2/simple_mut=
ex.c">simple_mutex.c</A>.<BR>Compile=20
with: <TT>gcc --pedantic -Wall -o simple_threads =
simple_mutex.c</TT>.<BR>Run=20
with: <TT>./simple_mutex</TT> </DIV>
<HR>
<A name=3Dipc__signals>
<H3>IPC: signals</H3></A>
<DIV class=3Dref_funcs>
<UL>
  <LI>kill(2)=20
  <LI>raise(3)=20
  <LI>signal(3) </LI></UL></DIV><BR>
<DIV class=3Dnotes><A name=3Dipc__signals_notes><B>Notes:</B></A><BR>A =
signal is a=20
very primitive kind of message. Process A can send process B a signal. =
If B=20
associated an handler to the given signal, that code will be executed =
when the=20
signal is received, interrupting the normal execution.<BR>Originally, =
signals=20
were simply unary values (received or not, like a beep): when a process =
received=20
the signal, it always reacted the same manner (historically, =
terminating, that=20
also explains the current name of the function you'll see below for =
sending=20
signals). Recently, signals have been "type-fied" (think about beeps of=20
different frequencies): when a process receives a signal, it reacts =
differently=20
depending on the signal's <I>type</I>. This type is an integer value. =
Some=20
values have been conventionally standardized and associated with =
symbolic names:=20
(15, TERM) and (20, CHLD) are popular examples. The full list is defined =
in=20
<TT>signal.h</TT>.<BR>Processes send signals with the <TT>kill()</TT> =
function.=20
A process may associate an handler function to a specific signal type =
with the=20
<TT>signal()</TT> function.<BR>Signal dispatching is controlled by the =
operating=20
system. A process A can signal another process only if they belong to =
the same=20
user. Processes run by a superuser can signal every process. Signals are =
often=20
sent by the OS itself, e.g. to kill a process when its execution caused =
problems=20
like memory segment violation. For some of these signals, the OS =
inhibits custom=20
handlers: SIGSTOP and SIGKILL will always make the process respectively =
stop and=20
die.<BR>Two standard handlers have been provided with the standard C =
library:=20
<TT>SIG_DFL</TT> causing process termination, and <TT>SIG_IGN</TT> =
causing the=20
signal to get ignored. When an handler fires for a signal, it won't be=20
interrupted by other handlers if more signals arrive.<BR>As last note: =
signals=20
are not queued (somehow, "best effort"). In order to notify signals, the =
OS=20
holds a bitmask for every process. When the process receives the signal=20
<I>n</I>, the <I>n</I>th bit in this bitmask is set. When the handler =
function=20
terminates, it's reset to 0. Thus, if the process is not scheduled for =
execution=20
(some of its user-space code) before other signals of the same type =
arrive, only=20
the last will be notified by the process. The others are lost. =
</DIV><BR>
<DIV class=3Dsummary><A =
name=3Dipc__signals_summary><B>Summary:</B></A><BR>
<UL>
  <LI>what to #include: <TT>signal.h</TT>=20
  <LI>types used: <TT>pid_t</TT>, <TT>sig_t</TT>=20
  <LI>functions:=20
  <OL>
    <LI><TT>void <B>signal</B>(int sig_type, void (*sig_handler)(int=20
    signal_type))</TT><BR><TT>sig_type</TT> is one of the signal values =
(or=20
    names) defined in <TT>signal.h</TT>. <TT>sig_handles</TT> is a =
pointer to a=20
    function taking an int argument. This function will be run in the =
process=20
    context when the process is hit by the signal of the specified type. =

    <LI><TT>int <B>kill</B>(pid_t dest_pid, int sig_type)</TT><BR>sends =
a signal=20
    of type <TT>sig_type</TT> to the process running with PID =
<TT>dest_pid</TT>.=20
    Particular types 0 and -1 of <TT>dest_pid</TT> make kill() =
respectively=20
    sends all processes executing with the same group of the sender, and =
signals=20
    all the processes running in the system (only works with superuser=20
    credentials).=20
    <LI><TT>void <B>raise</B>(int sig_type)</TT><BR>signals itself with =
signal=20
    <TT>sig_type</TT>. </LI></OL>
  <LI>Other things to know:=20
  <UL>
    <LI>signals are only delivered between processes when either:=20
    <OL>
      <LI>the processes involved are run by the same user=20
      <LI>the raising process is run by a superuser </LI></OL>
    <LI>signal types and type names are defined in <TT>signal.h</TT>=20
    <LI>signals are not queued=20
    <LI>handlers "terminate process" (SIG_DFL) and "ignore signal" =
(SIG_IGN) are=20
    already defined in <TT>signal.h</TT> </LI></UL></LI></UL></DIV>
<DIV class=3Dexamples><A =
name=3Dipc__signals_examples><B>Examples:</B></A><BR>1)=20
Handling signals coming from the operating system. This example =
implements a=20
solution to the problem of purging the queue of exit statuses of dead =
children.=20
Whenever a child changes its status, the parent is signaled (by the OS) =
with=20
"SIGCHLD". A SIGCHLD handler can be associated with this event. There =
are 2=20
important things to note for this process:=20
<OL>
  <LI>the signal handler may catch all the dead children, or not. The =
random=20
  sequence delaying forks contributes to signals overlapping phenomenon. =

  <LI>the raise of the signal handler (<TT>child_handler()</TT>) turn =
the=20
  process back in a "running" state. In this case, it breaks the sleep() =

  functions before the exhaust their module. </LI></OL>
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  sig_purgechilds.c
 * =20
 *  The parent process pulls a child exit status whenever the OS =
notifies
 *  a child status change.
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on 04/01/05.
 *  Original source file available at =
http://mij.oltrelinux.com/devel/unixprg/
 *
 */</SPAN>

<SPAN class=3Dccom>/* for printf() and fgetc() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
</SPAN><SPAN class=3Dccom>/* for fork() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
</SPAN><SPAN class=3Dccom>/* for srandom() and random() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdlib.h&gt;
</SPAN><SPAN class=3Dccom>/* for time() [seeding srandom()] */</SPAN>
<SPAN class=3Dcpdr>#include &lt;time.h&gt;
</SPAN><SPAN class=3Dccom>/* for waitpid() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;sys/wait.h&gt;
</SPAN><SPAN class=3Dccom>/* for signal(), kill() and raise() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;signal.h&gt;
</SPAN>
<SPAN class=3Dccom>/* how many childs to raise */</SPAN>
<SPAN class=3Dcpdr>#define NUM_PROCS   </SPAN><SPAN =
class=3Dcval>5</SPAN><SPAN class=3Dcpdr>
</SPAN>

<SPAN class=3Dccom>/* handler prototype for SIGCHLD */</SPAN>
<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>child_handler</SPAN>(<SPAN class=3Dctyp>int</SPAN>);

<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>(<SPAN =
class=3Dctyp>int</SPAN> argc, <SPAN class=3Dctyp>char</SPAN> *argv[])
{
    <SPAN class=3Dctyp>int</SPAN> i, exit_status;
   =20
   =20
    <SPAN class=3Dccom>/* execute child_handler() when receiving a =
signal of type SIGCHLD */</SPAN>
    <SPAN class=3Dcfun>signal</SPAN>(SIGCHLD, &amp;child_handler);

    <SPAN class=3Dccom>/* initialize the random num generator */</SPAN>
    <SPAN class=3Dcfun>srandom</SPAN>(<SPAN =
class=3Dcfun>time</SPAN>(<SPAN class=3Dctyp>NULL</SPAN>));
   =20
   =20
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Try to issue a =
\'ps\' while the process is running...\n"</SPAN>);
   =20
   =20
    <SPAN class=3Dccom>/* produce NUM_PROCS childs */</SPAN>
    <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(i =3D <SPAN =
class=3Dcval>0</SPAN>; i &lt; NUM_PROCS; i++) {
        <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(! <SPAN =
class=3Dcfun>fork</SPAN>()) {
            <SPAN class=3Dccom>/* child */</SPAN>
           =20
            <SPAN class=3Dccom>/* choosing a random exit status between =
0 and 99 */</SPAN>
            exit_status =3D (<SPAN class=3Dctyp>int</SPAN>)(<SPAN =
class=3Dcfun>random</SPAN>() % <SPAN class=3Dcval>100</SPAN>);
            <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>" -&gt; =
New child %d, will exit with %d.\n"</SPAN>, (<SPAN =
class=3Dctyp>int</SPAN>)<SPAN class=3Dcfun>getpid</SPAN>(), =
exit_status);
           =20
            <SPAN class=3Dccom>/* try to skip signals overlapping =
*/</SPAN>
            <SPAN class=3Dcfun>sleep</SPAN>((<SPAN =
class=3Dctyp>unsigned</SPAN> <SPAN class=3Dctyp>int</SPAN>)(<SPAN =
class=3Dcfun>random</SPAN>() % <SPAN class=3Dcval>3</SPAN>));
           =20
            <SPAN class=3Dccom>/* choosing a value to exit between 0 and =
99 */</SPAN>
            <SPAN class=3Dcfun>exit</SPAN>(exit_status);
        }=20
       =20
        <SPAN class=3Dccom>/* father */</SPAN>
        <SPAN class=3Dcfun>sleep</SPAN>((<SPAN =
class=3Dctyp>unsigned</SPAN> <SPAN class=3Dctyp>int</SPAN>)(<SPAN =
class=3Dcfun>random</SPAN>() % <SPAN class=3Dcval>2</SPAN>));
    }

    <SPAN class=3Dccom>/* checkpoint */</SPAN>
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"parent: done =
with fork()ing.\n"</SPAN>);

    <SPAN class=3Dccom>/* why this is not equivalent to sleep(20) here? =
*/</SPAN>
    <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(i =3D <SPAN =
class=3Dcval>0</SPAN>; i &lt; <SPAN class=3Dcval>10</SPAN>; i++) {
        <SPAN class=3Dcfun>sleep</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }
    <SPAN class=3Dccom>/* all the child processes should be done now =
*/</SPAN>
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"I did not purge =
all the childs. Timeout; exiting.\n"</SPAN>);
   =20
    <SPAN class=3Dccom>/* terminate myself =3D&gt; exit */</SPAN>
    <SPAN class=3Dcfun>kill</SPAN>(<SPAN class=3Dcfun>getpid</SPAN>(), =
<SPAN class=3Dcval>15</SPAN>);
   =20
    <SPAN class=3Dccom>/* this won't be actually executed */</SPAN>
    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}


<SPAN class=3Dccom>/* handler definition for SIGCHLD */</SPAN>
<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>child_handler</SPAN>(<SPAN class=3Dctyp>int</SPAN> =
sig_type)
{
    <SPAN class=3Dctyp>int</SPAN> child_status;
    pid_t child;
    <SPAN class=3Dctyp>static</SPAN> <SPAN class=3Dctyp>int</SPAN> =
call_num =3D <SPAN class=3Dcval>0</SPAN>;

    <SPAN class=3Dccom>/* getting the child's exit status */</SPAN>
    child =3D <SPAN class=3Dcfun>waitpid</SPAN>(<SPAN =
class=3Dcval>0</SPAN>, &amp;child_status, <SPAN class=3Dcval>0</SPAN>);
   =20
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"&lt;-  Child %d =
exited with status %d.\n"</SPAN>, child, <SPAN =
class=3Dcfun>WEXITSTATUS</SPAN>(child_status));=20
   =20
    <SPAN class=3Dccom>/* did we get all the childs? */</SPAN>
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(++call_num =
&gt;=3D NUM_PROCS) {
        <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"I got all =
the childs this time. Going to exit.\n"</SPAN>);
        <SPAN class=3Dcfun>exit </SPAN>(<SPAN class=3Dcval>0</SPAN>);
    }
   =20
    <SPAN class=3Dctyp>return</SPAN>;
}
</PRE></DIV><BR>You can download the original ascii source file with =
this link:=20
<A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/ipc__signals/sig_pur=
gechilds.c">sig_purgechilds.c</A>.<BR>Compile=20
with: <TT>gcc -o sig_purgechilds -Wall --ansi sig_purgechilds.c</TT> =
.<BR>Run=20
with: <TT>./sig_purgechilds.c</TT> . </DIV><BR>
<HR>
<A name=3Dipc__pipes>
<H3>IPC: pipes</H3></A>
<DIV class=3Dref_funcs>
<UL>
  <LI>pipe(2) </LI></UL></DIV><BR>
<DIV class=3Dnotes><A name=3Dipc__pipes_notes><B>Notes:</B></A><BR>A =
pipe is an=20
uni-directional mean to send data. On UNIX systems, it's implemented =
with a=20
couple of file descriptors. What is written on the first one can be read =
from=20
the second one, with a FIFO order.<BR>Pipes are one of the easiest and =
fastest=20
way for implementing IPC between two processes. Commonly, a process =
creates two=20
pipes X and Y and forks to a child. The child will inherit these data. =
The=20
parent will message the child on X_w (the write descriptor of the X =
pipe), and=20
the child will receive on X_r. In analogy, the child will write to the =
parent on=20
Y_w; the parent can read from Y_r. Using the same pipe for =
bi-directional=20
communication can bring high-quality messes, so the fair way to =
implement=20
bi-directional communication is just to use two pipes (P1 to P2, and P2 =
to=20
P1).<BR>Thereby, it is clear that <I>n*(n-1)</I> pipes are needed for a =
<I>n</I>=20
processes to intercommunicate together.<BR>Atomicity of pipe operations =
is=20
guaranteed by the OS if the length of the message is shorter than a =
specific=20
value (carried by the <TT>PIPE_BUF</TT> macro), but if this information =
is=20
relevant for you, pipes are probably not a good programming choice for =
your=20
scenario.<BR>When one of the two pipe ends is closed, the pipe becomes=20
<I>widowed</I> (or <I>broken</I>). Writing to a widowed pipe is not =
permitted by=20
the OS. On such a trial, the process is signalled with a SIGPIPE. =
Reading from=20
widowed pipes always returns 0 bytes. This is often used to notify one =
end=20
process the communication is finished. </DIV><BR>
<DIV class=3Dsummary><A =
name=3Dipc__pipes_summary><B>Summary:</B></A><BR>
<UL>
  <LI>what to #include: <TT>unistd.h</TT>=20
  <LI>functions:=20
  <OL>
    <LI><TT>int <B>pipe</B>(int *fd_couple)</TT><BR>creates a pipe and =
stores=20
    its file descriptors to <TT>fd_couple[0]</TT> (read end) and =
fd_couple[1]=20
    (write end). -1 is returned on errors while creating, 0 otherwise. =
</LI></OL>
  <LI>Other things to know:=20
  <OL>
    <LI>pipes are uni-directional=20
    <LI>atomicity is guaranteed for messages shorter than =
<TT>PIPE_BUF</TT>=20
    bytes=20
    <LI>half-open pipes are told <I>widowed</I> (or <I>broken</I>) =
pipes.=20
    Writing on them causes a write error, reading from them always =
returns 0=20
    bytes. </LI></OL></LI></UL></DIV>
<DIV class=3Dexamples><A =
name=3Dipc__pipes_examples><B>Examples:</B></A><BR>1) a set=20
of processes messaging together. Every process gets its own pipe (couple =
of file=20
descriptors). When process <I>i</I> wants to message process <I>j</I>, =
it writes=20
onto <I>j</I>'s pipe write end. Every process will get its messages =
reading from=20
the read end of its own pipe. This is a de-genere example with processes =
only=20
reading the first 2 messages they got. The full solution can be =
implemented with=20
the help of the select() function.=20
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  pipes.c
 * =20
 *  A set of processes randomly messaging each the other, with pipes.
 *
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on 05/01/05.
 *  Original source file available on =
http://mij.oltrelinux.com/devel/unixprg/
 *
 */</SPAN>

<SPAN class=3Dccom>/* ... */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
</SPAN><SPAN class=3Dccom>/* for read() and write() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;sys/types.h&gt;
#include &lt;sys/uio.h&gt;
</SPAN><SPAN class=3Dccom>/* for strlen and others */</SPAN>
<SPAN class=3Dcpdr>#include &lt;string.h&gt;
</SPAN><SPAN class=3Dccom>/* for pipe() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;unistd.h&gt;
</SPAN><SPAN class=3Dccom>/* for [s]random() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdlib.h&gt;
</SPAN><SPAN class=3Dccom>/* for time() [seeding srandom()] */</SPAN>
<SPAN class=3Dcpdr>#include &lt;time.h&gt;
</SPAN>

<SPAN class=3Dcpdr>#define PROCS_NUM               </SPAN><SPAN =
class=3Dcval>15</SPAN><SPAN class=3Dcpdr>          /* </SPAN><SPAN =
class=3Dcval>1</SPAN><SPAN class=3Dcpdr> &lt; number of processes =
involved &lt;=3D </SPAN><SPAN class=3Dcval>255</SPAN><SPAN class=3Dcpdr> =
*/
#define MAX_PAYLOAD_LENGTH      </SPAN><SPAN class=3Dcval>50</SPAN><SPAN =
class=3Dcpdr>          /* message length */
#define DEAD_PROC               -</SPAN><SPAN class=3Dcval>1</SPAN><SPAN =
class=3Dcpdr>          /* a value to mark a dead process' file =
descriptors with */
</SPAN>

        <SPAN class=3Dccom>/*      ***                     DATA TYPES    =
              ***     */</SPAN>
<SPAN class=3Dccom>/* a process address */</SPAN>
<SPAN class=3Dctyp>typedef</SPAN> <SPAN class=3Dctyp>char</SPAN> =
proc_addr;

<SPAN class=3Dccom>/* a message */</SPAN>
<SPAN class=3Dctyp>struct</SPAN> message_s {
    proc_addr src_id;
    <SPAN class=3Dctyp>short</SPAN> <SPAN class=3Dctyp>int</SPAN> =
length;
    <SPAN class=3Dctyp>char</SPAN> *payload;
};


        <SPAN class=3Dccom>/*      ***                     FUNCTION =
PROTOTYPES         ***     */</SPAN>
<SPAN class=3Dccom>/* send message to process with id dest */</SPAN>
<SPAN class=3Dctyp>int</SPAN> <SPAN =
class=3Dcfun>send_proc_message</SPAN>(proc_addr dest, <SPAN =
class=3Dctyp>char</SPAN> *message);
<SPAN class=3Dccom>/* receive a message in the process' queue of =
received ones */</SPAN>
<SPAN class=3Dctyp>int</SPAN> <SPAN =
class=3Dcfun>receive_proc_message</SPAN>(<SPAN =
class=3Dctyp>struct</SPAN> message_s *msg);
<SPAN class=3Dccom>/* mark process file descriptors closed */</SPAN>
<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>mark_proc_closed</SPAN>(proc_addr process);


        <SPAN class=3Dccom>/*              ***             GLOBAL VARS   =
              ***     */</SPAN>
<SPAN class=3Dccom>/* they are OK to be global here. */</SPAN>
proc_addr my_address;                   <SPAN class=3Dccom>/* stores the =
id of the process */</SPAN>
<SPAN class=3Dctyp>int</SPAN> proc_pipes[PROCS_NUM][<SPAN =
class=3Dcval>2</SPAN>];           <SPAN class=3Dccom>/* stores the pipes =
of every process involved */</SPAN>


<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>(<SPAN =
class=3Dctyp>int</SPAN> argc, <SPAN class=3Dctyp>char</SPAN> *argv[])
{
    pid_t child_pid;
    pid_t my_children[PROCS_NUM];               <SPAN class=3Dccom>/* =
PIDs of the children */</SPAN>
    <SPAN class=3Dctyp>int</SPAN> i, ret;
    <SPAN class=3Dctyp>char</SPAN> msg_text[MAX_PAYLOAD_LENGTH];       =
<SPAN class=3Dccom>/* payload of the message to send */</SPAN>
    proc_addr msg_recipient;                   =20
    <SPAN class=3Dctyp>struct</SPAN> message_s msg;
   =20
   =20
   =20
    <SPAN class=3Dccom>/* create a pipe for me (the parent) */</SPAN>
    <SPAN class=3Dcfun>pipe</SPAN>(proc_pipes[<SPAN =
class=3Dcval>0</SPAN>]);

    <SPAN class=3Dccom>/* initializing proc_pipes struct */</SPAN>
    <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(i =3D <SPAN =
class=3Dcval>1</SPAN>; i &lt; PROCS_NUM; i++) {
        <SPAN class=3Dccom>/* creating one pipe for every (future) =
process */</SPAN>
        ret =3D <SPAN class=3Dcfun>pipe</SPAN>(proc_pipes[i]);
        <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(ret) {
            <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"Error =
creating pipe"</SPAN>);
            <SPAN class=3Dcfun>abort</SPAN>();
        }       =20
    }
       =20
   =20
    <SPAN class=3Dccom>/* fork [1..NUM_PROCS] children. 0 is me. =
*/</SPAN>
    <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(i =3D <SPAN =
class=3Dcval>1</SPAN>; i &lt; PROCS_NUM; i++) {
        <SPAN class=3Dccom>/* setting the child address */</SPAN>
        my_address =3D my_address + <SPAN class=3Dcval>1</SPAN>;
       =20
        child_pid =3D <SPAN class=3Dcfun>fork</SPAN>();
        <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(! =
child_pid) {
            <SPAN class=3Dccom>/* child */</SPAN>
            <SPAN class=3Dcfun>sleep</SPAN>(<SPAN =
class=3Dcval>1</SPAN>);

            <SPAN class=3Dccom>/* closing other process' pipes read ends =
*/</SPAN>
            <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(i =
=3D <SPAN class=3Dcval>0</SPAN>; i &lt; PROCS_NUM; i++) {
                <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> =
</SPAN>(i !=3D my_address)
                    <SPAN class=3Dcfun>close</SPAN>(proc_pipes[i][<SPAN =
class=3Dcval>0</SPAN>]);
            }
           =20
           =20
            <SPAN class=3Dccom>/* init random num generator */</SPAN>
            <SPAN class=3Dcfun>srandom</SPAN>(<SPAN =
class=3Dcfun>time</SPAN>(<SPAN class=3Dctyp>NULL</SPAN>));

            <SPAN class=3Dccom>/* my_address is now my address, and will =
hereby become a "constant" */</SPAN>
            <SPAN class=3Dccom>/* producing some message for the other =
processes */</SPAN>
            <SPAN class=3Dctyp>while</SPAN><SPAN class=3Dcfun> =
</SPAN>(<SPAN class=3Dcfun>random</SPAN>() % (<SPAN =
class=3Dcval>2</SPAN>*PROCS_NUM)) {
                <SPAN class=3Dccom>/* interleaving... */</SPAN>
                <SPAN class=3Dcfun>sleep</SPAN>((<SPAN =
class=3Dctyp>unsigned</SPAN> <SPAN class=3Dctyp>int</SPAN>)(<SPAN =
class=3Dcfun>random</SPAN>() % <SPAN class=3Dcval>2</SPAN>));
               =20
                <SPAN class=3Dccom>/* choosing a random recipient =
(including me) */</SPAN>
                msg_recipient =3D (proc_addr)(<SPAN =
class=3Dcfun>random</SPAN>() % PROCS_NUM);
               =20
                <SPAN class=3Dccom>/* preparing and sending the message =
*/</SPAN>
                <SPAN class=3Dcfun>sprintf</SPAN>(msg_text, <SPAN =
class=3Dcstr>"hello from process %u."</SPAN>, (<SPAN =
class=3Dctyp>int</SPAN>)my_address);
                ret =3D <SPAN =
class=3Dcfun>send_proc_message</SPAN>(msg_recipient, msg_text);
                <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> =
</SPAN>(ret &gt; <SPAN class=3Dcval>0</SPAN>) {
                    <SPAN class=3Dccom>/* message has been correctly =
sent */</SPAN>
                    <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"    --&gt; %d: sent message to %u\n"</SPAN>, my_address, =
msg_recipient);
                } <SPAN class=3Dctyp>else</SPAN> {
                    <SPAN class=3Dccom>/* the child we tried to message =
does no longer exist */</SPAN>
                    <SPAN =
class=3Dcfun>mark_proc_closed</SPAN>(msg_recipient);
                    <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"    --&gt; %d: recipient %u is no longer =
available\n"</SPAN>, my_address, msg_recipient);
                }
            }
           =20
            <SPAN class=3Dccom>/* now, reading the first 2 messages =
we've been sent */</SPAN>
            <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(i =
=3D <SPAN class=3Dcval>0</SPAN>; i &lt; <SPAN class=3Dcval>2</SPAN>; =
i++) {
                ret =3D <SPAN =
class=3Dcfun>receive_proc_message</SPAN>(&amp;msg);
                <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> =
</SPAN>(ret &lt; <SPAN class=3Dcval>0</SPAN>) <SPAN =
class=3Dctyp>break</SPAN>;
                <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"&lt;--     Process %d, received message from %u: =
\"%s\".\n"</SPAN>, my_address, msg.src_id, msg.payload);
            };
           =20
            <SPAN class=3Dccom>/* i'm exiting. making my pipe widowed =
*/</SPAN>
            <SPAN class=3Dcfun>close</SPAN>(proc_pipes[my_address][<SPAN =
class=3Dcval>0</SPAN>]);
           =20
            <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"# %d: i =
am exiting.\n"</SPAN>, my_address);
            <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>0</SPAN>);
        }
       =20
        <SPAN class=3Dccom>/* saving the child pid (for future killing) =
*/</SPAN>
        my_children[my_address] =3D child_pid;

        <SPAN class=3Dccom>/* parent. I don't need the read descriptor =
of the pipe */</SPAN>=20
        <SPAN class=3Dcfun>close</SPAN>(proc_pipes[my_address][<SPAN =
class=3Dcval>0</SPAN>]);
       =20
        <SPAN class=3Dccom>/* this is for making srandom() consistent =
*/</SPAN>
        <SPAN class=3Dcfun>sleep</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }
   =20
    <SPAN class=3Dccom>/* expecting the user request to terminate... =
*/</SPAN>
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Please press =
ENTER when you like me to flush the children...\n"</SPAN>);
    <SPAN class=3Dcfun>getchar</SPAN>();

    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Ok, terminating =
dandling processes...\n"</SPAN>);
    <SPAN class=3Dccom>/* stopping freezed children */</SPAN>
    <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(i =3D <SPAN =
class=3Dcval>1</SPAN>; i &lt; PROCS_NUM; i++) {
        <SPAN class=3Dcfun>kill</SPAN>(my_children[i], SIGTERM);
    }
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Done. =
Exiting.\n"</SPAN>);
   =20
    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}


<SPAN class=3Dctyp>int</SPAN> <SPAN =
class=3Dcfun>send_proc_message</SPAN>(proc_addr dest, <SPAN =
class=3Dctyp>char</SPAN> *message)
{
    <SPAN class=3Dctyp>int</SPAN> ret;
    <SPAN class=3Dctyp>char</SPAN> *msg =3D (<SPAN =
class=3Dctyp>char</SPAN> *)<SPAN class=3Dcfun>malloc</SPAN>(<SPAN =
class=3Dctyp>sizeof</SPAN>(message) + <SPAN class=3Dcval>2</SPAN>);
   =20
   =20
    <SPAN class=3Dccom>/* the write should be atomic. Doing our best =
*/</SPAN>
    msg[<SPAN class=3Dcval>0</SPAN>] =3D (<SPAN =
class=3Dctyp>char</SPAN>)dest;
    <SPAN class=3Dcfun>memcpy</SPAN>((<SPAN class=3Dctyp>void</SPAN> =
*)&amp;(msg[<SPAN class=3Dcval>1</SPAN>]), (<SPAN =
class=3Dctyp>void</SPAN> *)message, <SPAN =
class=3Dcfun>strlen</SPAN>(message)+<SPAN class=3Dcval>1</SPAN>);
   =20
    <SPAN class=3Dccom>/* send message, including the "header" the =
trailing '\0' */</SPAN>
    ret =3D <SPAN class=3Dcfun>write</SPAN>(proc_pipes[dest][<SPAN =
class=3Dcval>1</SPAN>], msg, <SPAN class=3Dcfun>strlen</SPAN>(msg)+<SPAN =
class=3Dcval>2</SPAN>);
    <SPAN class=3Dcfun>free</SPAN>(msg);
   =20
    <SPAN class=3Dctyp>return</SPAN> ret;
}


<SPAN class=3Dctyp>int</SPAN> <SPAN =
class=3Dcfun>receive_proc_message</SPAN>(<SPAN =
class=3Dctyp>struct</SPAN> message_s *msg)
{
    <SPAN class=3Dctyp>char</SPAN> c =3D <SPAN class=3Dcval>'x'</SPAN>;
    <SPAN class=3Dctyp>char</SPAN> temp_string[MAX_PAYLOAD_LENGTH];
    <SPAN class=3Dctyp>int</SPAN> ret, i =3D <SPAN =
class=3Dcval>0</SPAN>;

   =20
    <SPAN class=3Dccom>/* first, getting the message sender */</SPAN>
    ret =3D <SPAN class=3Dcfun>read</SPAN>(proc_pipes[my_address][<SPAN =
class=3Dcval>0</SPAN>], &amp;c, <SPAN class=3Dcval>1</SPAN>);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(ret =3D=3D =
<SPAN class=3Dcval>0</SPAN>) {
        <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
    }
    msg-&gt;src_id =3D (proc_addr)c;

    <SPAN class=3Dctyp>do</SPAN> {
        ret =3D <SPAN =
class=3Dcfun>read</SPAN>(proc_pipes[my_address][<SPAN =
class=3Dcval>0</SPAN>], &amp;c, <SPAN class=3Dcval>1</SPAN>);
        temp_string[i++] =3D c;
    } <SPAN class=3Dctyp>while</SPAN><SPAN class=3Dcfun> </SPAN>((ret =
&gt; <SPAN class=3Dcval>0</SPAN>) &amp;&amp; (c !=3D '\<SPAN =
class=3Dcval>0</SPAN>') &amp;&amp; (i &lt; MAX_PAYLOAD_LENGTH));

   =20
   =20
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(c =3D=3D =
'\<SPAN class=3Dcval>0</SPAN>') {
        <SPAN class=3Dccom>/* msg correctly received. Preparing message =
packet */</SPAN>
       =20
        msg-&gt;payload =3D (<SPAN class=3Dctyp>char</SPAN> *)<SPAN =
class=3Dcfun>malloc</SPAN>(<SPAN class=3Dcfun>strlen</SPAN>(temp_string) =
+ <SPAN class=3Dcval>1</SPAN>);
        <SPAN class=3Dcfun>strncpy</SPAN>(msg-&gt;payload, temp_string, =
<SPAN class=3Dcfun>strlen</SPAN>(temp_string) + <SPAN =
class=3Dcval>1</SPAN>);
       =20
        <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
    }


    <SPAN class=3Dctyp>return</SPAN> -<SPAN class=3Dcval>1</SPAN>;
}


<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>mark_proc_closed</SPAN>(proc_addr process)
{
    proc_pipes[process][<SPAN class=3Dcval>0</SPAN>] =3D DEAD_PROC;
    proc_pipes[process][<SPAN class=3Dcval>1</SPAN>] =3D DEAD_PROC;
}
</PRE></DIV><BR>You can download the original ascii source file with =
this link:=20
<A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/ipc__pipes/pipes.c">=
pipes.c</A>.<BR>Compile=20
with: <TT>gcc --ansi --pedantic -o pipes pipes.c</TT><BR>Run with:=20
<TT>./pipes</TT> </DIV>
<HR>
<A name=3Dipc__named_pipes>
<H3>IPC: named pipes</H3></A>
<DIV class=3Dref_funcs>
<UL>
  <LI>mkfifo(2) </LI></UL></DIV><BR>
<DIV class=3Dnotes><A =
name=3Dipc__named_pipes_notes><B>Notes:</B></A><BR>There isn't=20
much to say about named pipes once you understood standard pipes. The =
former=20
ones are just a simple extension to the latter. In order to create a =
common pipe=20
you use the <TT>pipe()</TT> function, and get a reference to it in terms =
of file=20
descriptors. This is the big limit of pipes: with file descriptors, they =
can=20
only be shared between processes with parent-child relationship. Named =
pipes=20
work much like common pipes, but they can be shared between independent=20
processes.<BR>You request a FIFO file to enter the filesystem with the=20
<TT>mkfifo()</TT> function. This takes as argument the name you want the =
file to=20
appear like. Every other process with opportune credentials could then =
handle=20
this special file with the standard <TT>open()</TT>, <TT>close()</TT>,=20
<TT>read()</TT> and <TT>write()</TT> file functions.<BR>The first =
process who=20
open the fifo is blocked until the other end is opened by someone. Of =
course,=20
being named pipes actual <I>pipes</I> in first place, they can't be =
applied=20
functions like <TT>lseek()</TT>. This is common to every stream file =
including=20
pipes, FIFOs and sockets. As a difference, being named pipes actually =
outside of=20
the inner, private scope of a process, they will survive the death of =
their=20
creator: they are persistent. This means that you must explicitly handle =
the=20
named pipe removal after you're done with it. <TT>unlink()</TT> is what =
you need=20
for this. </DIV><BR>
<DIV class=3Dsummary><A =
name=3Dipc__named_pipes_summary><B>Summary:</B></A><BR>
<UL>
  <LI>what to #include: <TT>sys/types.h</TT> and <TT>sys/stat.h</TT>=20
  <LI>functions:=20
  <OL>
    <LI><TT>int <B>mkfifo</B>(char *path, mode_t =
mode)</TT><BR><TT>path</TT> is=20
    the (path+)name of the FIFO file to create. <TT>mode</TT> is the =
file=20
    permission (see <I>umask(2)</I> and <I>chmod(2)</I>). It returns =
non-zero on=20
    errors. </LI></OL>
  <LI>Other things to know:=20
  <OL>
    <LI>standard pipes' properties and features.=20
    <LI>pipes are accessed like standard files except for positioning =
which=20
    doesn't work (being they fifos...)=20
    <LI>File owner and groups are set respectively to the user the =
caller is=20
    running as and the owner of the directory where the fifo is created=20
    <LI>user space commands are also available for creating named pipes =
from the=20
    shell. This is actually the most common use, very suitable to get =
different=20
    processes unaware each the other to communicate. =
</LI></OL></LI></UL></DIV>
<DIV class=3Dexamples><A =
name=3Dipc__named_pipes_examples><B>Examples:</B></A><BR>1)=20
a simple example. There's not much more to address about =
fifos.<BR>That's what=20
you do to try this:=20
<OL>
  <LI>you create the named pipe from the command line: <TT>mkfifo=20
  /tmp/named_pipe</TT>=20
  <LI>you compile this program, and run it=20
  <LI>you write something on the pipe: <TT>echo "this is a message" &gt; =

  /tmp/named_pipe</TT>=20
  <LI>you try what happens when skipping the string terminator: <TT>echo =
-n=20
  "this is another message" &gt; /tmp/named_pipe</TT>=20
  <LI>then try to load a terminator on the fifo: <TT>echo "a third =
message" &gt;=20
  /tmp/named_pipe</TT>=20
  <LI>when you're happy with your test, close the program. Then remove =
the pipe:=20
  <TT>rm /tmp/named_pipe</TT> </LI></OL>
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  nampipes.c
 * =20
 *  simply opens a pre-created named pipe (a "fifo") and reads
 *  stuff from it as soon as there's something available.
 *
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on 02/02/05.
 *  Original source file available on =
http://mij.oltrelinux.com/devel/unixprg/
 *
 */</SPAN>


<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;unistd.h&gt;
</SPAN>
<SPAN class=3Dcpdr>#define MAX_LINE_LENGTH
</SPAN>

<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>(<SPAN =
class=3Dctyp>int</SPAN> argc, <SPAN class=3Dctyp>char</SPAN> *argv[]) {
    <SPAN class=3Dctyp>int</SPAN> pipe;
    <SPAN class=3Dctyp>char</SPAN> ch;
   =20

    <SPAN class=3Dccom>/* we expect a named pipe has been created
     * in /tmp/named_pipe . The command
     *   $ mkfifo /tmp/named_pipe
     * is a friend to get to this point
     */</SPAN>
    pipe =3D <SPAN class=3Dcfun>open</SPAN>(<SPAN =
class=3Dcstr>"/tmp/named_pipe"</SPAN>, O_RDONLY);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(pipe &lt; =
<SPAN class=3Dcval>0</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"Opening =
pipe"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }
       =20
    <SPAN class=3Dccom>/* preparing to read from the pipe... */</SPAN>
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Waiting data =
from the pipe... \n"</SPAN>);

    <SPAN class=3Dccom>/* reading one char a time from the pipe =
*/</SPAN>
    <SPAN class=3Dctyp>while</SPAN><SPAN class=3Dcfun> </SPAN>(<SPAN =
class=3Dcval>1</SPAN>) {
        <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(<SPAN =
class=3Dcfun>read</SPAN>(pipe, &amp;ch, <SPAN class=3Dcval>1</SPAN>) =
&lt; <SPAN class=3Dcval>0</SPAN>) {
            <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"Read =
the pipe"</SPAN>);
            <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>2</SPAN>);
        }
       =20
        <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"%c"</SPAN>, =
ch);
    }
   =20
    <SPAN class=3Dccom>/* leaving the pipe */</SPAN>
    <SPAN class=3Dcfun>close</SPAN>(pipe);
   =20
    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}
</PRE></DIV><BR>You can download the original ascii source file with =
this link:=20
<A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/ipc__nampipes/nampip=
es.c">nampipes.c</A>.<BR>Compile=20
with: <TT>gcc --ansi --Wall -o nampipes nampipes.c</TT><BR>Read the =
instructions=20
above, then run with: <TT>./nampipes</TT> </DIV>
<HR>
<A name=3Dipc__sockets>
<H3>IPC: BSD sockets</H3></A>
<DIV class=3Dref_funcs>
<UL>
  <LI>socket(2)=20
  <LI>bind(2)=20
  <LI>listen(2)=20
  <LI>connect(2)=20
  <LI>sendto(2)=20
  <LI>recvfrom(2)=20
  <LI>[ write(2) and read(2) ] </LI></UL></DIV><BR>
<DIV class=3Dnotes><A =
name=3Dipc__sockets_notes><B>Notes:</B></A><BR>Sockets are the=20
representation that the operating system provides for network endpoints =
to=20
processes. They originated in 4.2BSD and are today an essential feature =
of every=20
UNIX system.<BR>Sockets are given a <I>type</I> and a set of attributes =
that=20
depend on it. These attributes include an address: the set of possible =
values=20
this address is taken from is told <I>domain</I>. As domains are =
distinct for=20
each type, sockets are typically distinguished just by the domain they =
are=20
addressed in. The most commonly used domains are the UNIX domain, that =
uses=20
filename-like addresses and is suitable only for in-host IPC, and the =
INET=20
domain, that uses IP addresses and can be used for both in-host and =
inter-host=20
IPC, but many more domains exist.<BR>Sockets can be connected or not.=20
Connectionful sockets require a setup phase before the actual =
communication=20
occurs, and a tear down phase after. Connectionless ones don't, but =
require a=20
slightly more complex semantic for sending and receiving every single=20
message.<BR>Connectionless sockets are point-to-anypoint and peer. This =
is the=20
lifecycle of a non-connected socket:=20
<OL>
  <LI>it is created (here the belonging domain is specified); --=20
  <TT>socket()</TT>=20
  <LI>it's bound attributes; -- <TT>bind()</TT>=20
  <LI>it is used for sending or receiving single messages; -- =
<TT>sendto()</TT>=20
  and <TT>recvfrom()</TT>=20
  <LI>it is closed -- <TT>close()</TT> </LI></OL>Connectionful sockets =
are=20
strictly point-to-point: once a connection is established, messages only =
travel=20
from/to the two entities involved. Connection also makes these sockets=20
master/slave or client/server (the one who initiate the connection is =
told slave=20
or client). This is the lifecycle of a connected socket with a role of =
server:=20
<OL>
  <LI>it is created (and assigned a domain); -- <TT>socket()</TT>=20
  <LI>it's bound attributes; -- <TT>bind()</TT>=20
  <LI>it's open into a network port (listening); -- <TT>listen()</TT>=20
  <LI>it accept connections; -- <TT>accept()</TT>=20
  <LI>data is read and written on it (it represent a stream once =
connected); --=20
  <TT>write()</TT> and <TT>read()</TT>=20
  <LI>it is closed -- <TT>close()</TT> </LI></OL>The lifecycle of a =
client is=20
similar, but features a connection request (<TT>connect()</TT>) in place =
of=20
points {2,3,4}.<BR>When connected, sockets appears much like a file: =
they can be=20
read and written the same way that file descriptors are.<BR>Sockets are =
blocking=20
by default: functions are suspended until the requested job on the =
socket=20
terminates. However, like regular file descriptors, sockets can be set=20
non-blocking too, with <TT>fcntl()</TT>. </DIV><BR>
<DIV class=3Dsummary><A =
name=3Dipc__sockets_summary><B>Summary:</B></A><BR>
<UL>
  <LI>what to #include: <TT>sys/types.h</TT>, <TT>sys/socket.h</TT> =
(socket,=20
  bind, listen, accept, connect, sendto, recvfrom), <TT>unistd.h</TT> =
(write,=20
  read and close). Then, <TT>netinet/in.h</TT> for INET-domain sockets, =
or=20
  <TT>sys/un.h</TT> for UNIX-domain sockets=20
  <LI>types:=20
  <OL>
    <LI><B>struct sockaddr</B>: a generic container for socket =
attributes; this=20
    is what expects <TT>bind()</TT>, but is actually instantiated every =
time=20
    with a domain-specific attribute structure like the ones below, =
eventually=20
    casted when necessary.=20
    <LI><B>struct sockaddr_in</B>: for INET domain socket attributes; =
defined as=20
    follows: <PRE>struct sockaddr_in {
        u_char  sin_len;
        u_char  sin_family;         /* =3D AF_INET */
        u_short sin_port;           /* use htons() to set this */
        struct  in_addr sin_addr;
        char    sin_zero[8];        /* 8 zeros required here */
};</PRE><PRE>struct in_addr {
        in_addr_t s_addr;           /* either use a macro from =
netinet/in.h (eg INADDR_ANY), or inet_addr */
};</PRE>
    <LI><B>struct sockaddr_un</B>: for UNIX domain socket attributes; =
defined=20
    as: <PRE>struct  sockaddr_un {
        u_char  sun_len;                /* sockaddr len including null =
*/
        u_char  sun_family;             /* AF_UNIX */
        char    sun_path[104];          /* path name */
};</PRE></LI></OL>
  <LI>useful macros:=20
  <OL>
    <LI><B>AF_*</B>: the socket domain ("Address Family"); from=20
    <TT>sys/socket.h</TT>=20
    <LI><B>INADDR_ANY</B>: for INET sockets, represents any possible =
address.=20
    <LI><B>SUN_LEN(struct sockaddr_un *su)</B>: for UNIX sockets, =
returns the=20
    address of a sockaddr_un structure initialized with a pathname; from =

    <TT>sys/un.h</TT>=20
    <LI><B>htons</B> &amp; Co.: for converting between machine and =
network byte=20
    order (necessary in inter-host communication) </LI></OL>
  <LI>functions:=20
  <OL>
    <LI><TT>int <B>socket</B>(int domain, int communication_type, int=20
    protocol)</TT><BR>creates a socket and returns its identifier, or -1 =
on=20
    errors (and <TT>errno</TT> is set). Pick <TT>domain</TT> and=20
    <TT>communication_type</TT> from <TT>sys/socket.h</TT>, e.g.=20
    <TT>AF_INET</TT> and <TT>SOCK_STREAM</TT>. The <TT>protocol</TT> =
field is=20
    domain-dependant</TT>.=20
    <LI><TT>int <B>bind</B>(int socket, const struct sockaddr *saddr, =
int=20
    saddrlen)</TT><BR>binds the attributes carried in <TT>saddr</TT> to =
the=20
    socket. <TT>saddrlen</TT> is the size of the actual structure =
passed: e.g.=20
    SUN_LEN(saddr) for UNIX domain sockets, or sizeof(struct =
sockaddr_in) for=20
    INET domain sockets. Return -1 on failure (sets <TT>errno</TT>).=20
    <LI><TT>int <B>listen</B>(int socket, int =
maxqueuelen)</TT><BR>applicable=20
    for connected sockets (SOCK_STREAM). Makes the socket listening for=20
    connections. <TT>maxqueuelen</TT> tells how many pending connections =
are=20
    accepted at most.i Returns 0 on success, -1 on failure =
(<TT>errno</TT> set).=20

    <LI><TT>int <B>connect</B>(int socket, const struct sockaddr =
*servaddr, int=20
    servaddrlen)</TT><BR>applicable for connected sockets (SOCK_STREAM): =

    connects the socket to the server described by <TT>servaddr</TT>.=20
    <TT>servaddrlen</TT> tells how long is the servaddr structure. =
Returns 0 on=20
    success, -1 on failure (and sets <TT>errno</TT>).=20
    <LI><TT><B>read</B>()</TT> and <TT><B>write</B>()</TT> can be used =
for=20
    reading and writing to (already) <U>connected</U> sockets just the =
way they=20
    are used for file descriptors. They are standard functions, their=20
    description is omitted.=20
    <LI><TT>int <B>recvfrom</B>(int socket, void *buf, size_t len, int =
flags,=20
    struct sockaddr *from, int *fromlen)</TT><BR>for disconnected =
sockets:=20
    receives a message, and stores it in <TT>buf</TT> for at most =
<TT>len</TT>=20
    bytes. <TT>flags</TT> is normally 0. If <TT>fromaddr</TT> is =
non-NULL and=20
    its size is set in <TT>fromlen</TT>, the address structure of the =
message=20
    sender is written into it. Returns the number of bytes actually =
accepted, or=20
    -1 on errors (<TT>errno</TT> set).=20
    <LI><TT>int <B>sendto</B>(int socket, void *message, size_t len, int =
flags,=20
    struct sockaddr *toaddr, int toaddr_len)</TT><BR>for disconnected =
sockets:=20
    sends the first <TT>len</TT> bytes of the buffer <TT>message</TT>, =
to the=20
    recipient specified in <TT>toaddr</TT> (<TT>toaddr_len</TT> tells =
the size=20
    of the actual structure). Returns the number of bytes sent, or -1 on =
failure=20
    (<TT>errno</TT> set). </LI></OL>
  <LI>other useful functions: <TT>inet_addr()</TT> &amp; Co.,=20
  <TT>gethostbyname()</TT> &amp; Co., </LI></UL></DIV>
<DIV class=3Dexamples><A=20
name=3Dipc__sockets_examples><B>Examples:</B></A><BR><B>N.B.</B>: It is =
an habit=20
(that I dislike) that examples about sockets include a sample client, a =
sample=20
server, and mr. sample client contacts mr. sample server and they are =
happy and=20
close the connection. These examples are not like that. Both connected =
and=20
connectionless sockets are presented. Besides, "standalone" clients and =
servers=20
are proposed: their functionality can be tested with standard tools like =

netcat.<BR><BR>1) an UDP server. A connectionless socket is opened on =
the local=20
internet-protocol interface "127.0.0.1", port "12321", and a message is =
awaited.=20
Once received, the message length and content are displayed, along with =
the IP=20
address and port of the sender.=20
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 * udpserv.c
 *
 * listens on an UDP port, accept one message and displays its content =
and
 * who's the sender
 *
 *
 * Created by Mij &lt;mij@bitchx.it&gt; on 18/12/05.
 * Original source file available on =
http://mij.oltrelinux.com/devel/unixprg/
 */</SPAN>

<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
</SPAN><SPAN class=3Dccom>/* socket(), bind(), recvfrom() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
</SPAN><SPAN class=3Dccom>/* sockaddr_in */</SPAN>
<SPAN class=3Dcpdr>#include &lt;netinet/in.h&gt;
</SPAN><SPAN class=3Dccom>/* inet_addr() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;arpa/inet.h&gt;
</SPAN><SPAN class=3Dccom>/* memset() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;string.h&gt;
</SPAN><SPAN class=3Dccom>/* close() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;unistd.h&gt;
</SPAN><SPAN class=3Dccom>/* exit() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdlib.h&gt;
</SPAN>
<SPAN class=3Dccom>/* maximum size available for an incoming message =
payload */</SPAN>
<SPAN class=3Dcpdr>#define MAX_MSGLEN      </SPAN><SPAN =
class=3Dcval>100</SPAN><SPAN class=3Dcpdr>
</SPAN>
<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>() {
    <SPAN class=3Dctyp>int</SPAN> sock, err;
    <SPAN class=3Dctyp>char</SPAN> messagebuf[MAX_MSGLEN+<SPAN =
class=3Dcval>1</SPAN>];
    <SPAN class=3Dctyp>struct</SPAN> sockaddr_in saddr, fromaddr;
    <SPAN class=3Dctyp>int</SPAN> fromaddr_len =3D <SPAN =
class=3Dctyp>sizeof</SPAN>(fromaddr);


    <SPAN class=3Dccom>/* create a INET-domain, disconnected (datagram) =
socket */</SPAN>
    sock =3D <SPAN class=3Dcfun>socket</SPAN>(AF_INET, SOCK_DGRAM, =
IPPROTO_UDP);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(sock &lt; =
<SPAN class=3Dcval>0</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
socket()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }

    <SPAN class=3Dccom>/* bind the following attributes to the socket: =
*/</SPAN>
    saddr.sin_family =3D AF_INET;
    saddr.sin_addr.s_addr =3D <SPAN class=3Dcfun>inet_addr</SPAN>(<SPAN =
class=3Dcstr>"127.0.0.1"</SPAN>);     <SPAN class=3Dccom>/* localhost =
address */</SPAN>
    saddr.sin_port =3D <SPAN class=3Dcfun>htons</SPAN>(<SPAN =
class=3Dcval>61321</SPAN>);          <SPAN class=3Dccom>/* use port =
61321 (with correct network byte-order */</SPAN>
    <SPAN class=3Dcfun>memset</SPAN>(&amp;saddr.sin_zero, <SPAN =
class=3Dcval>0</SPAN>, <SPAN =
class=3Dctyp>sizeof</SPAN>(saddr.sin_zero)); <SPAN class=3Dccom>/* =
always zero-fill this field! */</SPAN>
   =20
    err =3D <SPAN class=3Dcfun>bind</SPAN>(sock, (<SPAN =
class=3Dctyp>struct</SPAN> sockaddr *)&amp;saddr, <SPAN =
class=3Dctyp>sizeof</SPAN>(saddr));
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(err) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
bind()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }
  =20
    <SPAN class=3Dccom>/* receive a message in "messagebuf" at most =
MAX_MSGLEN bytes long (1 is
     * spared for the trailing '\0'; store sender info in "fromaddr" =
*/</SPAN>
    err =3D <SPAN class=3Dcfun>recvfrom</SPAN>(sock, messagebuf, =
MAX_MSGLEN-<SPAN class=3Dcval>1</SPAN>, <SPAN class=3Dcval>0</SPAN>, =
(<SPAN class=3Dctyp>struct</SPAN> sockaddr *)&amp;fromaddr, =
&amp;fromaddr_len);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(err &lt;=3D =
<SPAN class=3Dcval>0</SPAN>) {     <SPAN class=3Dccom>/* otherwise, =
"err" tells how many bytes have been written in "messagebuf" */</SPAN>
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"in =
recvfrom()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }
    messagebuf[err] =3D '\<SPAN class=3Dcval>0</SPAN>';        <SPAN =
class=3Dccom>/* NULL-terminator */</SPAN>

    <SPAN class=3Dccom>/* close the socket */</SPAN>
    <SPAN class=3Dcfun>close</SPAN>(sock);
   =20
    <SPAN class=3Dccom>/* displaying message length and content =
*/</SPAN>
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Message:\n\t@bytes: %d\n\t@payload: %s\n"</SPAN>, err, =
messagebuf);
    <SPAN class=3Dccom>/* displaying sender info: */</SPAN>
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Sender:\n\t@address: %s\n\t@port: %d\n"</SPAN>, <SPAN =
class=3Dcfun>inet_ntoa</SPAN>(fromaddr.sin_addr), <SPAN =
class=3Dcfun>ntohs</SPAN>(fromaddr.sin_port));

    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}
</PRE></DIV><BR>You can download the original ascii source file with =
this link:=20
<A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/ipc__sockets/1/udpse=
rv.c">udpserv.c</A>.<BR>Compile=20
with: <TT>gcc -o udpserv udpserv.c</TT><BR>Run the server in a=20
terminal:<BR><TT>$ ./udpserv</TT><BR>Then, open another terminal and =
feed=20
something on UDP on 127.0.0.1 port 61321 via UDP, e.g. with =
netcat:<BR><TT>$=20
echo -n "Hello lame server." | nc -u 127.0.0.1 61321</TT><BR>Also try =
omitting=20
the newline (here, take "-n" away), and sending large messages (eg, cat =
a whole=20
file).=20
<HR>
2) A UNIX domain client. It connects to a given server, sends a message =
to it,=20
expects a newline-terminated response, then displays all this and exits. =

<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 * unixcli.c
 *
 * connects to an UNIX domain socket, sends a message to it, and =
disconnects.
 *
 *
 * Created by Mij &lt;mij@bitchx.it&gt; on 18/12/05.
 * Original source file available on =
http://mij.oltrelinux.com/devel/unixprg/
 */</SPAN>

<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
</SPAN><SPAN class=3Dccom>/* socket(), bind() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;
</SPAN><SPAN class=3Dccom>/* write(), close() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;unistd.h&gt;
</SPAN><SPAN class=3Dccom>/* strlen() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;string.h&gt;
</SPAN><SPAN class=3Dccom>/* exit() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdlib.h&gt;
</SPAN>
<SPAN class=3Dccom>/* maximum size available for an incoming message =
payload */</SPAN>
<SPAN class=3Dcpdr>#define MAX_MSGLEN      </SPAN><SPAN =
class=3Dcval>100</SPAN><SPAN class=3Dcpdr>
</SPAN><SPAN class=3Dccom>/* path of the UNIX domain socket in =
filesystem */</SPAN>
<SPAN class=3Dcpdr>#define SERVERSOCK_PATH     "/tmp/mytmpunixsock"
</SPAN>
<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>() {
    <SPAN class=3Dctyp>int</SPAN> sock, err, i =3D <SPAN =
class=3Dcval>0</SPAN>;
    <SPAN class=3Dctyp>char</SPAN> ch, messagebuf[MAX_MSGLEN];
    <SPAN class=3Dctyp>struct</SPAN> sockaddr_un servaddr;


    <SPAN class=3Dccom>/* create a UNIX domain, connectionful socket =
*/</SPAN>
    sock =3D <SPAN class=3Dcfun>socket</SPAN>(AF_UNIX, SOCK_STREAM, =
<SPAN class=3Dcval>0</SPAN>);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(sock &lt; =
<SPAN class=3Dcval>0</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
socket()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }

    <SPAN class=3Dccom>/* connect the socket to the server socket =
described by "servaddr" */</SPAN>
    servaddr.sun_family =3D AF_UNIX;
    <SPAN class=3Dcfun>sprintf</SPAN>(servaddr.sun_path, =
SERVERSOCK_PATH);

    err =3D <SPAN class=3Dcfun>connect</SPAN>(sock, (<SPAN =
class=3Dctyp>struct</SPAN> sockaddr *)&amp;servaddr, <SPAN =
class=3Dctyp>sizeof</SPAN>(servaddr));
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(err) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
connect()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }

    <SPAN class=3Dccom>/* write a message to the server */</SPAN>
    err =3D <SPAN class=3Dcfun>write</SPAN>(sock, <SPAN =
class=3Dcstr>"Hello server.\n"</SPAN>, <SPAN =
class=3Dcfun>strlen</SPAN>(<SPAN class=3Dcstr>"Hello =
server.\n"</SPAN>));
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(err &lt; =
<SPAN class=3Dcval>0</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
write()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }

    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Message =
sent:\n\t@length: %d bytes\n\t@content: %s\n"</SPAN>, err, <SPAN =
class=3Dcstr>"Hello server.\n"</SPAN>);

    <SPAN class=3Dccom>/* receive the response from the server */</SPAN>
    <SPAN class=3Dctyp>do</SPAN> {
        err =3D <SPAN class=3Dcfun>read</SPAN>(sock, &amp;ch, <SPAN =
class=3Dcval>1</SPAN>);       <SPAN class=3Dccom>/* read one byte from =
the socket */</SPAN>
        <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(err =
&lt;=3D <SPAN class=3Dcval>0</SPAN>) {
            <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Premature end-of-file (0) or read() error (&lt;0)? =
%d\n"</SPAN>, err);
            <SPAN class=3Dctyp>break</SPAN>;
        }
        messagebuf[i++] =3D ch;
    } <SPAN class=3Dctyp>while</SPAN><SPAN class=3Dcfun> </SPAN>(ch !=3D =
'\n');
    messagebuf[i] =3D '\<SPAN class=3Dcval>0</SPAN>';
  =20
    <SPAN class=3Dccom>/* close the socket */</SPAN>
    <SPAN class=3Dcfun>close</SPAN>(sock);
   =20
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Response =
received:\n\t@length: %lu bytes\n\t@content: %s\n"</SPAN>, <SPAN =
class=3Dcfun>strlen</SPAN>(messagebuf), messagebuf);

    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}
        </PRE></DIV><BR>You can download the original ascii source file =
with=20
this link: <A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/ipc__sockets/2/unixc=
li.c">unixcli.c</A>=20
.<BR>Compile with: <TT>gcc -o unixcli unixcli.c</TT><BR>Before running,=20
establish a UNIX domain socket, e.g. with socat:<BR><TT>$ socat=20
UNIX-LISTEN:/tmp/mytmpunixsock -</TT><BR>In another terminal, run the =
client=20
with:<BR><TT>$ ./unixcli</TT><BR>You see the message incoming from the =
client to=20
the server in the first terminal. The client expects a response now: =
type=20
something (newline-terminated) and see what the client tells. Also try=20
interrupting the connection prematurely by Ctrl-C 'ing the server. =
(Manually=20
remove the socket created by socat after use). </DIV>
<HR>
<A name=3Dipc__posix_msgqs>
<H3>IPC: POSIX Message queues</H3></A>
<DIV class=3Dref_funcs>
<UL>
  <LI>mq_open(3)=20
  <LI>mq_close(3)=20
  <LI>mq_unlink(3)=20
  <LI>mq_send(3)=20
  <LI>mq_receive(3)=20
  <LI>mq_getattr(3)=20
  <LI>mq_setattr(3) </LI></UL></DIV><BR>
<DIV class=3Dnotes><A =
name=3Dipc__posix_msgqs_notes><B>Notes:</B></A><BR>Message=20
queues are an handy way to get IPC when working with unrelated processes =
that=20
run completely without synchronism. A message queue is a shared "box" =
where=20
processes can drop and withdraw messages independently. Besides the =
content,=20
each message is given a "priority". Message queues first appeared in =
System V.=20
POSIX standardized this IPC mechanism with the 1003.1b ("realtime") =
standard in=20
1993, but the resulting standard is describing a slightly different =
behavior wrt=20
the former historical implementation. This is about the POSIX=20
interface.<BR>Message queues objects are referenced by a unique POSIX =
object=20
name in the system as usual. The opening function (<TT>mq_open()</TT>) =
is the=20
only one to use that name, while an internal reference returned by it =
will be=20
used to reference the queue for the remainder of the =
program.<BR>Messages are=20
sent to the queue with the <TT>mq_send()</TT> (blocking by default). =
They can be=20
any kind of information, nothing is dictated on the structure of a =
message. On=20
sending, the message is to be accompanied by a priority. This priority =
is used=20
for delivering messages: every time a process request for a receive =
(invoking=20
the <TT>mq_receive()</TT> function, also blocking by default), the =
oldest=20
message with the highest priority will be given. This differs from the =
SysV API,=20
in which the user explicitly request for a specific priority, causing =
this=20
priority being frequently used as recipient address.<BR>Several features =
of the=20
message queue can be set on creation or, in part, on a later time with =
the=20
<TT>mq_setattr()</TT> function. Between them, the maximum size of a =
message is=20
worth particular attention: each process invoking a receive won't be =
serviced,=20
and EMSGSIZE will be set in <TT>errno</TT> if the length of the buffer =
for the=20
message is shorter than this maximum size. </DIV><BR>
<DIV class=3Dsummary><A =
name=3Dipc__posix_msgqs_summary><B>Summary:</B></A><BR>
<UL>
  <LI>message queues are available with the System V API and the POSIX =
API. This=20
  is about the latter=20
  <LI>what to #include: <TT>mqueue.h</TT> (<TT>sys/stat.h</TT> for using =

  permission macros while creating queues)=20
  <LI>types:=20
  <OL>
    <LI><B>mqd_t</B>: a message queue descriptor.=20
    <LI><B>struct mq_attr</B>: a message queue attributes structure, =
defined as=20
    follows: <PRE>struct mq_attr {
    long int mq_flags;    /* Message queue flags.  */
    long int mq_maxmsg;   /* Maximum number of messages.  */
    long int mq_msgsize;  /* Maximum message size.  */
    long int mq_curmsgs;  /* Number of messages currently queued.  */
}
</PRE></LI></OL>
  <LI>functions:=20
  <OL>
    <LI><TT>mqd_t <B>mq_open</B>(const char *name, int flags, ... [ =
mode_t mode,=20
    struct mq_attr *mq_attr ])</TT><BR>opens the queue referenced by=20
    <TT>name</TT> for access, where <TT>flags</TT> can request:=20
    <TT>O_RDONLY</TT>, <TT>O_WRONLY</TT>, <TT>O_RDWR</TT> for access =
permission,=20
    and <TT>O_CREAT</TT>, <TT>O_EXCL</TT> or <TT>O_NONBLOCK</TT> as =
intuitive,=20
    respectively, for create queue, fail create if already existing, and =

    non-blocking behavior. If O_CREAT is specified, two more fields are=20
    requested: <TT>mode</TT> expliciting object permissions (S_IRWXU, =
S_IRWXG=20
    etc you can inspect in chmod(2); include <TT>sys/stat.h</TT> for =
these), and=20
    <TT>mq_attr</TT> expliciting the characteristics wanted for the =
queue. The=20
    latter can be set to <TT>NULL</TT> for using defaults, but mind the =
message=20
    size problem discussed in Notes above.<BR>Returns the message =
descriptor, or=20
    (mqd_t)-1 on error.=20
    <LI><TT>int <B>mq_close</B>(mdq_t mqdes)</TT><BR>closes the queue =
described=20
    by <TT>mqdes</TT>. Returns 0 for ok, otherwise -1.=20
    <LI><TT>int <B>mq_unlink</B>(const char *name)</TT><BR>like=20
    <TT>unlink</TT>(2), but with the posix object referenced by=20
    <TT>name</TT>.<BR>Returns 0, or -1 on error.=20
    <LI><TT>int <B>mq_send</B>(mqd_t mqdes, const char *msgbuf, size_t =
len,=20
    unsigned int prio)</TT><BR>sends <TT>len</TT> bytes from =
<TT>msgbuf</TT> to=20
    the queue <TT>mqdes</TT>, associating a <TT>prio</TT> =
priority.<BR>Return 0=20
    on succes, -1 otherwise.=20
    <LI><TT>ssize_t <B>mq_receive</B>(mqd_t mqdes, char *buf, size_t =
len,=20
    unsigned *prio)</TT><BR>takes the oldest message with the highest =
priority=20
    from <TT>mqdes</TT> into <TT>buf</TT>. The <TT>len</TT> field =
determines an=20
    important effect described in Notes above. <TT>prio</TT>, if not =
NULL, is=20
    filled with the priority of the given message.<BR>Returns the length =
of the=20
    message received, or -1 on error.=20
    <LI><TT>int <B>mq_getattr</B>(mqd_t mqdes, struct mq_attr=20
    *mq_attr)</TT><BR>provides the attributes associated to =
<TT>mqdes</TT> by=20
    filling at <TT>mq_attr</TT> with the structure shown =
above.<BR>Returns 0, or=20
    -1 on error.=20
    <LI><TT>int <B>mq_setattr</B>(mqd_t mqdes, const struct mq_attr =
*mqstat,=20
    struct mq_attr *omqstat)</TT><BR>for <TT>mqdes</TT>, sets the =
attributes=20
    carried by <TT>mqstat</TT>. In fact, only the <TT>mq_flags</TT> =
member of=20
    this structure applies (for setting O_NONBLOCK): the other ones are =
simply=20
    ignored and can be set just when the queue is created. The =
<TT>omqstat</TT>=20
    is commonly NULL, or it will be filled with the previous attributes =
and the=20
    current queue status.<BR>Returns 0, or -1 on error and the queue =
won't be=20
    touched. </LI></OL>
  <LI>further notes on persistence: message queues both in the POSIX and =
System=20
  V implementation features kernel-level persistence=20
  <LI>further notes on System V message queues: while the semantic is =
quite the=20
  same as for POSIX, System V message queues use a different namespace =
for=20
  functions for opening, creating, sending, receiving etc. See the =
msgget,=20
  msgctl, msgsnd, msgrcv man pages for more about this older API. =
</LI></UL></DIV>
<DIV class=3Dexamples><A =
name=3Dipc__posix_msgqs_examples><B>Examples:</B></A><BR>1)=20
Handling creation/opening of message queues, sending/receiving of =
messages and=20
the essence of queue attributes. Try running several times the message =
producer=20
before running the consumer. Try running the consumer more times than =
the=20
producer. Try looping the producer until the queue fills. Try running =
the=20
consumer after decreasing MAX_MSG_LEN under what's displayed by the =
queue=20
attributes.=20
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  dropone.c
 * =20
 *  drops a message into a #defined queue, creating it if user
 *  requested. The message is associated a priority still user
 *  defined
 *
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on 07/08/05.
 *  Original source file available on =
http://mij.oltrelinux.com/devel/unixprg/
 *
 */</SPAN>

<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
</SPAN><SPAN class=3Dccom>/* mq_* functions */</SPAN>
<SPAN class=3Dcpdr>#include &lt;mqueue.h&gt;
#include &lt;sys/stat.h&gt;
</SPAN><SPAN class=3Dccom>/* exit() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdlib.h&gt;
</SPAN><SPAN class=3Dccom>/* getopt() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;unistd.h&gt;
</SPAN><SPAN class=3Dccom>/* ctime() and time() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;time.h&gt;
</SPAN><SPAN class=3Dccom>/* strlen() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;string.h&gt;
</SPAN>

<SPAN class=3Dccom>/* name of the POSIX object referencing the queue =
*/</SPAN>
<SPAN class=3Dcpdr>#define MSGQOBJ_NAME    "/myqueue123"
</SPAN><SPAN class=3Dccom>/* max length of a message (just for this =
process) */</SPAN>
<SPAN class=3Dcpdr>#define MAX_MSG_LEN     </SPAN><SPAN =
class=3Dcval>70</SPAN><SPAN class=3Dcpdr>
</SPAN>

<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>(<SPAN =
class=3Dctyp>int</SPAN> argc, <SPAN class=3Dctyp>char</SPAN> *argv[]) {
    mqd_t msgq_id;
    <SPAN class=3Dctyp>unsigned</SPAN> <SPAN class=3Dctyp>int</SPAN> =
msgprio =3D <SPAN class=3Dcval>0</SPAN>;
    pid_t my_pid =3D <SPAN class=3Dcfun>getpid</SPAN>();
    <SPAN class=3Dctyp>char</SPAN> msgcontent[MAX_MSG_LEN];
    <SPAN class=3Dctyp>int</SPAN> create_queue =3D <SPAN =
class=3Dcval>0</SPAN>;
    <SPAN class=3Dctyp>char</SPAN> ch;            <SPAN class=3Dccom>/* =
for getopt() */</SPAN>
    time_t currtime;
   =20
   =20
    <SPAN class=3Dccom>/* accepting "-q" for "create queue", requesting =
"-p prio" for message priority */</SPAN>
    <SPAN class=3Dctyp>while</SPAN><SPAN class=3Dcfun> </SPAN>((ch =3D =
<SPAN class=3Dcfun>getopt</SPAN>(argc, argv, <SPAN =
class=3Dcstr>"qi:"</SPAN>)) !=3D -<SPAN class=3Dcval>1</SPAN>) {
        <SPAN class=3Dctyp>switch</SPAN><SPAN class=3Dcfun> </SPAN>(ch) =
{
            <SPAN class=3Dctyp>case</SPAN> <SPAN =
class=3Dcval>'q'</SPAN>:   <SPAN class=3Dccom>/* create the queue =
*/</SPAN>
                create_queue =3D <SPAN class=3Dcval>1</SPAN>;
                <SPAN class=3Dctyp>break</SPAN>;
            <SPAN class=3Dctyp>case</SPAN> <SPAN =
class=3Dcval>'p'</SPAN>:   <SPAN class=3Dccom>/* specify client id =
*/</SPAN>
                msgprio =3D (<SPAN class=3Dctyp>unsigned</SPAN> <SPAN =
class=3Dctyp>int</SPAN>)<SPAN class=3Dcfun>strtol</SPAN>(optarg, (<SPAN =
class=3Dctyp>char</SPAN> **)<SPAN class=3Dctyp>NULL</SPAN>, <SPAN =
class=3Dcval>10</SPAN>);
                <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"I =
(%d) will use priority %d\n"</SPAN>, my_pid, msgprio);
                <SPAN class=3Dctyp>break</SPAN>;
            <SPAN class=3Dctyp>default</SPAN>:
                <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>"Usage: %s [-q] -p msg_prio\n"</SPAN>, argv[<SPAN =
class=3Dcval>0</SPAN>]);
                <SPAN class=3Dcfun>exit</SPAN>(<SPAN =
class=3Dcval>1</SPAN>);
        }
    }
   =20
    <SPAN class=3Dccom>/* forcing specification of "-i" argument =
*/</SPAN>
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(msgprio =
=3D=3D <SPAN class=3Dcval>0</SPAN>) {
        <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Usage: %s =
[-q] -p msg_prio\n"</SPAN>, argv[<SPAN class=3Dcval>0</SPAN>]);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }
   =20
    <SPAN class=3Dccom>/* opening the queue        --  mq_open() =
*/</SPAN>
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> =
</SPAN>(create_queue) {
        <SPAN class=3Dccom>/* mq_open() for creating a new queue (using =
default attributes) */</SPAN>
        msgq_id =3D <SPAN class=3Dcfun>mq_open</SPAN>(MSGQOBJ_NAME, =
O_RDWR | O_CREAT | O_EXCL, S_IRWXU | S_IRWXG, <SPAN =
class=3Dctyp>NULL</SPAN>);
    } <SPAN class=3Dctyp>else</SPAN> {
        <SPAN class=3Dccom>/* mq_open() for opening an existing queue =
*/</SPAN>
        msgq_id =3D <SPAN class=3Dcfun>mq_open</SPAN>(MSGQOBJ_NAME, =
O_RDWR);
    }
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(msgq_id =
=3D=3D (mqd_t)-<SPAN class=3Dcval>1</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
mq_open()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }

    <SPAN class=3Dccom>/* producing the message */</SPAN>
    currtime =3D <SPAN class=3Dcfun>time</SPAN>(<SPAN =
class=3Dctyp>NULL</SPAN>);
    <SPAN class=3Dcfun>snprintf</SPAN>(msgcontent, MAX_MSG_LEN, <SPAN =
class=3Dcstr>"Hello from process %u (at %s)."</SPAN>, my_pid, <SPAN =
class=3Dcfun>ctime</SPAN>(&amp;currtime));
   =20
    <SPAN class=3Dccom>/* sending the message      --  mq_send() =
*/</SPAN>
    <SPAN class=3Dcfun>mq_send</SPAN>(msgq_id, msgcontent, <SPAN =
class=3Dcfun>strlen</SPAN>(msgcontent)+<SPAN class=3Dcval>1</SPAN>, =
msgprio);
   =20
    <SPAN class=3Dccom>/* closing the queue        -- mq_close() =
*/</SPAN>
    <SPAN class=3Dcfun>mq_close</SPAN>(msgq_id);
   =20
       =20
    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}
</PRE></DIV><BR>
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  takeone.c
 * =20
 *  simply request a message from a queue, and displays queue
 *  attributes.
 *
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on 07/08/05.
 *  Original source file available on =
http://mij.oltrelinux.com/devel/unixprg/
 *
 */</SPAN>

<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
</SPAN><SPAN class=3Dccom>/* mq_* functions */</SPAN>
<SPAN class=3Dcpdr>#include &lt;mqueue.h&gt;
</SPAN><SPAN class=3Dccom>/* exit() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdlib.h&gt;
</SPAN><SPAN class=3Dccom>/* getopt() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;unistd.h&gt;
</SPAN><SPAN class=3Dccom>/* ctime() and time() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;time.h&gt;
</SPAN><SPAN class=3Dccom>/* strlen() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;string.h&gt;
</SPAN>

<SPAN class=3Dccom>/* name of the POSIX object referencing the queue =
*/</SPAN>
<SPAN class=3Dcpdr>#define MSGQOBJ_NAME    "/myqueue123"
</SPAN><SPAN class=3Dccom>/* max length of a message (just for this =
process) */</SPAN>
<SPAN class=3Dcpdr>#define MAX_MSG_LEN     </SPAN><SPAN =
class=3Dcval>10000</SPAN><SPAN class=3Dcpdr>
</SPAN>

<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>(<SPAN =
class=3Dctyp>int</SPAN> argc, <SPAN class=3Dctyp>char</SPAN> *argv[]) {
    mqd_t msgq_id;
    <SPAN class=3Dctyp>char</SPAN> msgcontent[MAX_MSG_LEN];
    <SPAN class=3Dctyp>int</SPAN> msgsz;
    <SPAN class=3Dctyp>unsigned</SPAN> <SPAN class=3Dctyp>int</SPAN> =
sender;
    <SPAN class=3Dctyp>struct</SPAN> mq_attr msgq_attr;
   =20
   =20
    <SPAN class=3Dccom>/* opening the queue        --  mq_open() =
*/</SPAN>
    msgq_id =3D <SPAN class=3Dcfun>mq_open</SPAN>(MSGQOBJ_NAME, O_RDWR);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(msgq_id =
=3D=3D (mqd_t)-<SPAN class=3Dcval>1</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
mq_open()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }

    <SPAN class=3Dccom>/* getting the attributes from the queue        =
--  mq_getattr() */</SPAN>
    <SPAN class=3Dcfun>mq_getattr</SPAN>(msgq_id, &amp;msgq_attr);
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Queue =
\"%s\":\n\t- stores at most %ld messages\n\t- large at most %ld bytes =
each\n\t- currently holds %ld messages\n"</SPAN>, MSGQOBJ_NAME, =
msgq_attr.mq_maxmsg, msgq_attr.mq_msgsize, msgq_attr.mq_curmsgs);

    <SPAN class=3Dccom>/* getting a message */</SPAN>
    msgsz =3D <SPAN class=3Dcfun>mq_receive</SPAN>(msgq_id, msgcontent, =
MAX_MSG_LEN, &amp;sender);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(msgsz =3D=3D =
-<SPAN class=3Dcval>1</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
mq_receive()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Received =
message (%d bytes) from %d: %s\n"</SPAN>, msgsz, sender, msgcontent);
   =20
    <SPAN class=3Dccom>/* closing the queue    --  mq_close() */</SPAN>
    <SPAN class=3Dcfun>mq_close</SPAN>(msgq_id);
   =20
   =20
    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}
</PRE></DIV><BR>You can download the original ascii source files with =
these=20
links: <A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/ipc__msgqueues/1/dro=
pone.c"><TT>dropone.c</TT></A>=20
and <A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/ipc__msgqueues/1/tak=
eone.c"><TT>takeone.c</TT></A>.<BR>Compile=20
with:<BR><TT>gcc --pedantic -Wall -o dropone dropone.c<BR>gcc --pedantic =
-Wall=20
-o takeone takeone.c </TT><BR>(some systems wrap these functions into a =
posix=20
realtime library: add <TT>-lrt</TT> for them -- e.g. Linux does) <BR>Run =
as=20
follows:<BR><TT>./dropone -p some_positive_integer</TT> (add <TT>-q</TT> =
the=20
first time)<BR><TT>./takeone</TT><BR>and try some of the tests described =
above=20
the sources.=20
<HR>
<BR>2) Working with queue attributes. This creates a queue with custom=20
attributes, and also tries to modify them at a later time. Look for what =

attributes are ignored, when and why.=20
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  msgqattrs.c
 * =20
 *  creates a posix message queue requesting custom attributes,
 *  and displays what attributes are taken into account and what
 *  are not, while both creating and while setting at a later time.
 *
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on 31/08/05.
 *  Original source file available on =
http://mij.oltrelinux.com/devel/unixprg/
 *
 */</SPAN>


<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
#include &lt;mqueue.h&gt;
#include &lt;sys/stat.h&gt;
</SPAN><SPAN class=3Dccom>/* exit() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdlib.h&gt;
</SPAN>

<SPAN class=3Dcpdr>#define MSGQOBJ_NAME        "/fooasd1431"
#define MAX_QMSG_SIZE       </SPAN><SPAN class=3Dcval>30</SPAN><SPAN =
class=3Dcpdr>
</SPAN>

<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>(<SPAN =
class=3Dctyp>int</SPAN> argc, <SPAN class=3Dctyp>char</SPAN> *argv[]) {
    mqd_t myqueue;
    <SPAN class=3Dctyp>struct</SPAN> mq_attr wanted_attrs, actual_attrs;
   =20
       =20
    <SPAN class=3Dccom>/* filling the attribute structure */</SPAN>
    wanted_attrs.mq_flags =3D <SPAN class=3Dcval>0</SPAN>;               =
     <SPAN class=3Dccom>/* no exceptional behavior (just O_NONBLOCK =
currently available)  */</SPAN>
    wanted_attrs.mq_maxmsg =3D <SPAN class=3Dcval>100</SPAN>;            =
     <SPAN class=3Dccom>/* room for at most 100 messages in the queue =
*/</SPAN>
    wanted_attrs.mq_msgsize =3D MAX_QMSG_SIZE;      <SPAN =
class=3Dccom>/* maximum size of a message */</SPAN>
    wanted_attrs.mq_curmsgs =3D <SPAN class=3Dcval>123</SPAN>;           =
     <SPAN class=3Dccom>/* this (current number of messages) will be =
ignored */</SPAN>
   =20
    <SPAN class=3Dccom>/* mq_open() for creating a new queue (using =
default attributes) */</SPAN>
    myqueue =3D <SPAN class=3Dcfun>mq_open</SPAN>(MSGQOBJ_NAME, O_RDWR | =
O_CREAT | O_EXCL, S_IRWXU | S_IRWXG, &amp;wanted_attrs);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(myqueue =
=3D=3D (mqd_t)-<SPAN class=3Dcval>1</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
mq_open()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }

    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Message queue =
created.\n"</SPAN>);
   =20
    <SPAN class=3Dccom>/* getting queue attributes after creation        =
  --  mq_getattr()    */</SPAN>
    <SPAN class=3Dcfun>mq_getattr</SPAN>(myqueue, &amp;actual_attrs);
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Attributes =
right after queue creation:\n\t- non blocking flag: %d\n\t- maximum =
number of messages: %ld\n\t- maximum size of a message: %ld\n\t- current =
number of messages: %ld\n"</SPAN>, (actual_attrs.mq_flags =3D=3D <SPAN =
class=3Dcval>0</SPAN> ? <SPAN class=3Dcval>0</SPAN> : <SPAN =
class=3Dcval>1</SPAN>), actual_attrs.mq_maxmsg, actual_attrs.mq_msgsize, =
actual_attrs.mq_curmsgs);
   =20
    <SPAN class=3Dccom>/* building the structure again for modifying the =
existent queue */</SPAN>
    wanted_attrs.mq_flags =3D O_NONBLOCK;
    wanted_attrs.mq_maxmsg =3D <SPAN class=3Dcval>350</SPAN>;            =
   <SPAN class=3Dccom>/* this will be ignored by mq_setattr() */</SPAN>
    wanted_attrs.mq_msgsize =3D MAX_QMSG_SIZE;    <SPAN class=3Dccom>/* =
this will be ignored by mq_setattr() */</SPAN>
    wanted_attrs.mq_curmsgs =3D <SPAN class=3Dcval>123</SPAN>;           =
   <SPAN class=3Dccom>/* this will be ignored by mq_setattr() */</SPAN>
   =20
    <SPAN class=3Dccom>/* trying to later set different attributes on =
the queue        --  mq_setattr()    */</SPAN>
    <SPAN class=3Dcfun>mq_setattr</SPAN>(myqueue, &amp;wanted_attrs, =
<SPAN class=3Dctyp>NULL</SPAN>);
   =20
    <SPAN class=3Dccom>/* getting queue attributes after creation =
*/</SPAN>
    <SPAN class=3Dcfun>mq_getattr</SPAN>(myqueue, &amp;actual_attrs);
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Attributes =
after setattr():\n\t- non blocking flag: %d\n\t- maximum number of =
messages: %ld\n\t- maximum size of a message: %ld\n\t- current number of =
messages: %ld\n"</SPAN>, (actual_attrs.mq_flags =3D=3D <SPAN =
class=3Dcval>0</SPAN> ? <SPAN class=3Dcval>0</SPAN> : <SPAN =
class=3Dcval>1</SPAN>), actual_attrs.mq_maxmsg, actual_attrs.mq_msgsize, =
actual_attrs.mq_curmsgs);
   =20
    <SPAN class=3Dccom>/* removing the queue from the system       --  =
mq_unlink() */</SPAN>
    <SPAN class=3Dcfun>mq_unlink</SPAN>(MSGQOBJ_NAME);
   =20
   =20
    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}</PRE></DIV><BR>You can download the original ascii source with this =
link: <A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/ipc__msgqueues/2/msg=
qattrs.c"><TT>msgqattrs.c</TT></A>.<BR>Compile=20
with:<BR><TT>gcc --pedantic -Wall -o msgqattrs msgqattrs.c</TT><BR>Run =
with:=20
<TT>./msgqattrs</TT> </DIV>
<HR>
<A name=3Dipc__posix_sem>
<H3>IPC: POSIX Semaphores</H3></A>
<DIV class=3Dref_funcs>
<UL>
  <LI>sem_init(2)=20
  <LI>sem_open(2)=20
  <LI>sem_close(2)=20
  <LI>sem_post(2)=20
  <LI>sem_wait(2)=20
  <LI>sem_trywait(2) </LI></UL></DIV><BR>
<DIV class=3Dnotes><A =
name=3Dipc__posix_sem_notes><B>Notes:</B></A><BR>In the real=20
world today, POSIX semaphores don't still get full support from OSes. =
Some=20
features are not yet implemented. The Web is nonetheless poor of =
documentation=20
about it, so the goal here is to leave some concepts; you will map into =
this or=20
the other implementation in the need. We'll hopefully enjoy better =
support=20
during the next years.<BR>Semaphores are a mechanism for controlling =
access to=20
shared resources. In their original form, they are associated to a =
single=20
resource, and contain a binary value: {<TT>free</TT>, <TT>busy</TT>}. If =
the=20
resource is shared between more threads (or procs), each thread waits =
for the=20
resource semaphore to switch <TT>free</TT>. At this time, it sets the =
semaphore=20
to <TT>busy</TT> and enters the critical region, accessing the resource. =
Once=20
the work is done with the resource, the process releases it back setting =
the=20
semaphore to <TT>free</TT>. The whole thing works because the semaphore =
value is=20
set directly by the kernel on request, so it's not subject to process=20
interleaving.<BR>Please mind that this mechanism doesn't provide mutex =
access to=20
a resource. It just provides support for processes to carry out the job=20
themselves, so it's completely up to the processes to take the semaphore =
up to=20
date and access the resource in respect of it.<BR>Semaphores can be =
easily=20
extended to support several accesses to a resource. If a resource can be =

accessed concurrently by <I>n</I> threads, the semaphore simply needs to =
hold an=20
integer value instead of a Boolean one. This integer would be =
initialized to=20
<I>n</I>, and each time it's positive value a process decrements it by 1 =
and=20
gets 1 slot in the resource. When the value reaches 0, no more slots are =

available and candidate threads have to wait for the resource to get =
available=20
("free" is no more appropriate in this case). In this case the semaphore =
is told=20
to be <I>locked</I>.<BR>This is the concept behind semaphores. Dijkstra =
has been=20
inspired by actual train semaphores when he designed them in '60s: this =
justify=20
their being very intuitive.<BR>There are 2 relevant APIs for such =
systems today:=20

<UL>
  <LI>System V semaphores=20
  <LI>POSIX semaphores </LI></UL>The former implementations being =
inherited by the=20
System V, and the latter being standardized by POSIX 1003.1b (year 1993, =
the=20
first one with real time extensions). SysV semaphores are older and more =

popular. POSIX ones are newer, cleaner, easier, and lighter against the=20
machine.<BR>Just like pipes, semaphores can be <I>named</I> or =
<I>unnamed</I>.=20
Unnamed semaphores can only be shared by related processes. The POSIX =
API=20
defines both these personalities. They just differ in creation and =
opening.=20
</DIV><BR>
<DIV class=3Dsummary><A =
name=3Dipc__posix_sem_summary><B>Summary:</B></A><BR>
<UL>
  <LI>always keep an eye on platform-specific implementations. It is =
common to=20
  deal with partial implementations. Make your way with the help of =
<I>man</I>.=20
  <LI>what to #include: <TT>semaphore.h</TT>=20
  <LI>types:=20
  <OL>
    <LI><TT><B>sem_t</B></TT>: a semaphore descriptor. Commonly passed =
by=20
    reference. </LI></OL>
  <LI>functions for activating <I>unnamed</I> semaphores:=20
  <OL>
    <LI><TT>int <B>sem_init</B>(sem_t *sem, int shared, unsigned int=20
    value)</TT><BR>the area pointed by <TT>sem</TT> is initialized with =
a new=20
    semaphore object. <TT>shared</TT> tells if the semaphore is local =
(0) or=20
    shared between several processes (non-0). This isn't vastly=20
    supported.<BR><TT>value</TT> is the number the semaphore is =
initialized=20
    with.<BR>Returns -1 if unsuccessful.=20
    <LI><TT>int <B>sem_destroy</B>(sem_t *sem)</TT><BR>deallocates =
memory=20
    associated with the semaphore pointed by <TT>sem</TT>.<BR>Returns 0 =
if=20
    successful, -1 otherwise. </LI></OL>
  <LI>functions for activating <I>named</I> semaphores:=20
  <OL start=3D3>
    <LI><TT>sem_t <B>sem_open</B>(const char *name, int flags,=20
    ...)</TT><BR>"<TT>, ...</TT>" is zero or one occurrence of =
"<TT>mode_t mode,=20
    unsigned int value</TT>" (see below).<BR>opens a named semaphore.=20
    <TT>name</TT> specify its location in the filesystem hierarchy.=20
    <TT>flags</TT> can be zero, or <TT>O_CREAT</TT> (possibly associated =
with=20
    <TT>O_EXCL</TT>). Non-zero means creating the semaphore if it =
doesn't=20
    already exist. O_CREAT requires two further parameters: =
<TT>mode</TT>=20
    specifying the permission set of the semaphore in the filesystem,=20
    <TT>value</TT> being the same as in <TT>sem_destroy()</TT>. =
<TT>O_CREAT</TT>=20
    causes an exclusive behaviour if it appears with <TT>O_EXCL</TT>: a =
failure=20
    is returned if a semaphore <TT>name</TT> already exists in this =
case.=20
    Further values have been designed, while rarely implemented:=20
    <TT>O_TRUNC</TT> for truncating if such semaphore already exists, =
and=20
    O_NONBLOCK for non-blocking mode.<BR><TT>sem_open</TT> returns the =
address=20
    of the semaphore if successful, SEM_FAILED otherwise.=20
    <LI><TT>int <B>sem_close</B>(sem_t *sem)</TT><BR>closes the =
semaphore=20
    pointed by <TT>sem</TT>. Returns 0 on success, -1 on failure.=20
    <LI><TT>int <B>sem_unlink</B>(const char name *name)</TT><BR>removes =
the=20
    semaphore <TT>name</TT> from the filesystem. Returns 0 on success, =
-1 on=20
    failure. </LI></OL>
  <LI>functions for working with open semaphores:=20
  <OL start=3D6>
    <LI><TT>int <B>sem_wait</B>(sem_t *sem)</TT><BR>waits until the =
semaphore=20
    <TT>sem</TT> is non-locked, then locks it and returns to the caller. =
Even=20
    without getting the semaphore unlocked, <TT>sem_wait</TT> may be =
interrupted=20
    with the occurrence of a signal.<BR>returns 0 on success, -1 on =
failure. If=20
    -1, <TT>sem</TT> is not modified by the function.=20
    <LI><TT>int <B>sem_trywait</B>(sem_t *sem)</TT><BR>tries to lock=20
    <TT>sem</TT> the same way <TT>sem_wait</TT> does, but doesn't hang =
if the=20
    semaphore is locked.<BR>Returns 0 on success (got semaphore), EAGAIN =
if the=20
    semaphore was locked.=20
    <LI><TT>int <B>sem_post</B>(sem_t *sem)</TT><BR>unlocks =
<TT>sem</TT>. Of=20
    course, this has to be atomic and non-reentrant. After this =
operation, some=20
    thread between those waiting for the semaphore to get free. =
Otherwise, the=20
    semaphore value simply steps up by 1.<BR>Returns 0 on success, -1 on =

    failure.=20
    <LI><TT>int <B>sem_getvalue</B>(sem_t *sem, int *restrict=20
    sval)</TT><BR>compiles <TT>sval</TT> with the current value of =
<TT>sem</TT>.=20
    <TT>sem</TT> may possibly change its value before =
<TT>sem_getvalue</TT>=20
    returns to the caller.<BR>Returns 0 on success, -1 on failure.=20
</LI></OL></LI></UL></DIV><BR>
<DIV class=3Dexamples><A =
name=3Dipc__posix_sem_examples><B>Examples:</B></A><BR>1)=20
Unnamed semaphores.<BR>One process; the main thread creates 2 threads. =
They=20
access their critical section with mutual exclusion. The first one=20
synchronously, the second one asynchronously.=20
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  semaphore.c
 * =20
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on 12/03/05.
 *  Original source file available at =
http://mij.oltrelinux.com/devel/unixprg/
 *
 */</SPAN>


<SPAN class=3Dcpdr>#define _POSIX_SOURCE
#include &lt;stdio.h&gt;
</SPAN><SPAN class=3Dccom>/* sleep() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
</SPAN><SPAN class=3Dccom>/* abort() and random stuff */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdlib.h&gt;
</SPAN><SPAN class=3Dccom>/* time() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;time.h&gt;
#include &lt;signal.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
</SPAN>

<SPAN class=3Dccom>/* this skips program termination when receiving =
signals */</SPAN>
<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>signal_handler</SPAN>(<SPAN class=3Dctyp>int</SPAN> type);

<SPAN class=3Dccom>/*
 * thread A is synchronous. When it needs to enter its
 * critical section, it can't do anything other than waiting.
 */</SPAN>
<SPAN class=3Dctyp>void</SPAN> *<SPAN class=3Dcfun>thread_a</SPAN>(<SPAN =
class=3Dctyp>void</SPAN> *);

<SPAN class=3Dccom>/*
 * thread B is asynchronous. When it tries to enter its
 * critical section, it switches back to other tasks if
 * it hasn't this availability.
 */</SPAN>
<SPAN class=3Dctyp>void</SPAN> *<SPAN class=3Dcfun>thread_b</SPAN>(<SPAN =
class=3Dctyp>void</SPAN> *);


<SPAN class=3Dccom>/* the semaphore */</SPAN>
sem_t mysem;

<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>(<SPAN =
class=3Dctyp>int</SPAN> argc, <SPAN class=3Dctyp>char</SPAN> *argv[])
{
    pthread_t mytr_a, mytr_b;
    <SPAN class=3Dctyp>int</SPAN> ret;
   =20
   =20
    <SPAN class=3Dcfun>srand</SPAN>(<SPAN class=3Dcfun>time</SPAN>(<SPAN =
class=3Dctyp>NULL</SPAN>));
    <SPAN class=3Dcfun>signal</SPAN>(SIGHUP, signal_handler);
    <SPAN class=3Dcfun>signal</SPAN>(SIGUSR1, signal_handler);

    <SPAN class=3Dccom>/*
     * creating the unnamed, local semaphore, and initialize it with
     * value 1 (max concurrency 1)
     */</SPAN>
    ret =3D <SPAN class=3Dcfun>sem_init</SPAN>(&amp;mysem, <SPAN =
class=3Dcval>0</SPAN>, <SPAN class=3Dcval>1</SPAN>);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(ret !=3D =
<SPAN class=3Dcval>0</SPAN>) {
        <SPAN class=3Dccom>/* error. errno has been set */</SPAN>
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"Unable to =
initialize the semaphore"</SPAN>);
        <SPAN class=3Dcfun>abort</SPAN>();
    }
   =20
    <SPAN class=3Dccom>/* creating the first thread (A) */</SPAN>
    ret =3D <SPAN class=3Dcfun>pthread_create</SPAN>(&amp;mytr_a, <SPAN =
class=3Dctyp>NULL</SPAN>, thread_a, <SPAN class=3Dctyp>NULL</SPAN>);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(ret !=3D =
<SPAN class=3Dcval>0</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"Unable to =
create thread"</SPAN>);
        <SPAN class=3Dcfun>abort</SPAN>();
    }

    <SPAN class=3Dccom>/* creating the second thread (B) */</SPAN>
    ret =3D <SPAN class=3Dcfun>pthread_create</SPAN>(&amp;mytr_b, <SPAN =
class=3Dctyp>NULL</SPAN>, thread_b, <SPAN class=3Dctyp>NULL</SPAN>);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(ret !=3D =
<SPAN class=3Dcval>0</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"Unable to =
create thread"</SPAN>);
        <SPAN class=3Dcfun>abort</SPAN>();
    }
   =20
    <SPAN class=3Dccom>/* waiting for thread_a to finish */</SPAN>
    ret =3D <SPAN class=3Dcfun>pthread_join</SPAN>(mytr_a, (<SPAN =
class=3Dctyp>void</SPAN> *)<SPAN class=3Dctyp>NULL</SPAN>);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(ret !=3D =
<SPAN class=3Dcval>0</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"Error in =
pthread_join"</SPAN>);
        <SPAN class=3Dcfun>abort</SPAN>();
    }

    <SPAN class=3Dccom>/* waiting for thread_b to finish */</SPAN>
    ret =3D <SPAN class=3Dcfun>pthread_join</SPAN>(mytr_b, <SPAN =
class=3Dctyp>NULL</SPAN>);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(ret !=3D =
<SPAN class=3Dcval>0</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"Error in =
pthread_join"</SPAN>);
        <SPAN class=3Dcfun>abort</SPAN>();
    }

    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}


<SPAN class=3Dctyp>void</SPAN> *<SPAN class=3Dcfun>thread_a</SPAN>(<SPAN =
class=3Dctyp>void</SPAN> *x)
{
    <SPAN class=3Dctyp>unsigned</SPAN> <SPAN class=3Dctyp>int</SPAN> i, =
num;
    <SPAN class=3Dctyp>int</SPAN> ret;
   =20
   =20
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>" -- thread A -- =
starting\n"</SPAN>);
    num =3D ((<SPAN class=3Dctyp>unsigned</SPAN> <SPAN =
class=3Dctyp>int</SPAN>)<SPAN class=3Dcfun>rand</SPAN>() % <SPAN =
class=3Dcval>40</SPAN>);
   =20
    <SPAN class=3Dccom>/* this does (do_normal_stuff, do_critical_stuff) =
n times */</SPAN>
    <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(i =3D <SPAN =
class=3Dcval>0</SPAN>; i &lt; num; i++) {
        <SPAN class=3Dccom>/* do normal stuff */</SPAN>
        <SPAN class=3Dcfun>sleep</SPAN>(<SPAN class=3Dcval>3</SPAN> + =
(<SPAN class=3Dcfun>rand</SPAN>() % <SPAN class=3Dcval>5</SPAN>));
       =20
        <SPAN class=3Dccom>/* need to enter critical section */</SPAN>
        <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>" -- thread =
A -- waiting to enter critical section\n"</SPAN>);
        <SPAN class=3Dccom>/* looping until the lock is acquired =
*/</SPAN>
        <SPAN class=3Dctyp>do</SPAN> {
            ret =3D <SPAN class=3Dcfun>sem_wait</SPAN>(&amp;mysem);
            <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(ret =
!=3D <SPAN class=3Dcval>0</SPAN>) {
                <SPAN class=3Dccom>/* the lock wasn't acquired */</SPAN>
                <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> =
</SPAN>(errno !=3D EINVAL) {
                    <SPAN class=3Dcfun>perror</SPAN>(<SPAN =
class=3Dcstr>" -- thread A -- Error in sem_wait. terminating -&gt; =
"</SPAN>);
                    <SPAN class=3Dcfun>pthread_exit</SPAN>(<SPAN =
class=3Dctyp>NULL</SPAN>);
                } <SPAN class=3Dctyp>else</SPAN> {
                    <SPAN class=3Dccom>/* sem_wait() has been =
interrupted by a signal: looping again */</SPAN>
                    <SPAN class=3Dcfun>printf</SPAN>(<SPAN =
class=3Dcstr>" -- thread A -- sem_wait interrupted. Trying again for the =
lock...\n"</SPAN>);
                }
            }
        } <SPAN class=3Dctyp>while</SPAN><SPAN class=3Dcfun> </SPAN>(ret =
!=3D <SPAN class=3Dcval>0</SPAN>);
        <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>" -- thread =
A -- lock acquired. Enter critical section\n"</SPAN>);
       =20
        <SPAN class=3Dccom>/* CRITICAL SECTION */</SPAN>
        <SPAN class=3Dcfun>sleep</SPAN>(<SPAN class=3Dcfun>rand</SPAN>() =
% <SPAN class=3Dcval>2</SPAN>);
       =20
        <SPAN class=3Dccom>/* done, now unlocking the semaphore =
*/</SPAN>
        <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>" -- thread =
A -- leaving critical section\n"</SPAN>);
        ret =3D <SPAN class=3Dcfun>sem_post</SPAN>(&amp;mysem);
        <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(ret !=3D =
<SPAN class=3Dcval>0</SPAN>) {
            <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>" -- =
thread A -- Error in sem_post"</SPAN>);
            <SPAN class=3Dcfun>pthread_exit</SPAN>(<SPAN =
class=3Dctyp>NULL</SPAN>);
        }
    }
   =20
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>" -- thread A -- =
closing up\n"</SPAN>);

    <SPAN class=3Dcfun>pthread_exit</SPAN>(<SPAN =
class=3Dctyp>NULL</SPAN>);
}


<SPAN class=3Dctyp>void</SPAN> *<SPAN class=3Dcfun>thread_b</SPAN>(<SPAN =
class=3Dctyp>void</SPAN> *x)
{
    <SPAN class=3Dctyp>unsigned</SPAN> <SPAN class=3Dctyp>int</SPAN> i, =
num;
    <SPAN class=3Dctyp>int</SPAN> ret;
   =20
   =20
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>" -- thread B -- =
starting\n"</SPAN>);
    num =3D ((<SPAN class=3Dctyp>unsigned</SPAN> <SPAN =
class=3Dctyp>int</SPAN>)<SPAN class=3Dcfun>rand</SPAN>() % <SPAN =
class=3Dcval>100</SPAN>);
   =20
    <SPAN class=3Dccom>/* this does (do_normal_stuff, do_critical_stuff) =
n times */</SPAN>
    <SPAN class=3Dctyp>for</SPAN><SPAN class=3Dcfun> </SPAN>(i =3D <SPAN =
class=3Dcval>0</SPAN>; i &lt; num; i++) {
        <SPAN class=3Dccom>/* do normal stuff */</SPAN>
        <SPAN class=3Dcfun>sleep</SPAN>(<SPAN class=3Dcval>3</SPAN> + =
(<SPAN class=3Dcfun>rand</SPAN>() % <SPAN class=3Dcval>5</SPAN>));
       =20
        <SPAN class=3Dccom>/* wants to enter the critical section =
*/</SPAN>
        ret =3D <SPAN class=3Dcfun>sem_trywait</SPAN>(&amp;mysem);
        <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(ret !=3D =
<SPAN class=3Dcval>0</SPAN>) {
            <SPAN class=3Dccom>/* either an error happened, or the =
semaphore is locked */</SPAN>
            <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> =
</SPAN>(errno !=3D EAGAIN) {
                <SPAN class=3Dccom>/* an event different from "the =
semaphore was locked" happened */</SPAN>
                <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>" -- =
thread B -- error in sem_trywait. terminating -&gt; "</SPAN>);
                <SPAN class=3Dcfun>pthread_exit</SPAN>(<SPAN =
class=3Dctyp>NULL</SPAN>);
            }
           =20
            <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>" -- =
thread B -- cannot enter critical section: semaphore locked\n"</SPAN>);
        } <SPAN class=3Dctyp>else</SPAN> {
            <SPAN class=3Dccom>/* CRITICAL SECTION */</SPAN>
            <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>" -- =
thread B -- enter critical section\n"</SPAN>);

            <SPAN class=3Dcfun>sleep</SPAN>(<SPAN =
class=3Dcfun>rand</SPAN>() % <SPAN class=3Dcval>10</SPAN>);
           =20
            <SPAN class=3Dccom>/* done, now unlocking the semaphore =
*/</SPAN>
            <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>" -- =
thread B -- leaving critical section\n"</SPAN>);
            <SPAN class=3Dcfun>sem_post</SPAN>(&amp;mysem);
        }
    }
   =20
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>" -- thread B -- =
closing up\n"</SPAN>);
   =20
    <SPAN class=3Dccom>/* joining main() */</SPAN>
    <SPAN class=3Dcfun>pthread_exit</SPAN>(<SPAN =
class=3Dctyp>NULL</SPAN>);
}


<SPAN class=3Dctyp>void</SPAN> <SPAN =
class=3Dcfun>signal_handler</SPAN>(<SPAN class=3Dctyp>int</SPAN> type)
{
    <SPAN class=3Dccom>/* do nothing */</SPAN>
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"process got =
signal %d\n"</SPAN>, type);
    <SPAN class=3Dctyp>return</SPAN>;
}
</PRE></DIV><BR>You can download the original ascii source with this =
link: <A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/ipc__semaphores/sema=
phore.c">semaphore.c</A>.<BR>Compile=20
with: <TT>gcc --pedantic -Wall -o semaphore semaphore.c</TT><BR>Run =
with:=20
<TT>./semaphore</TT> </DIV>
<HR>
<BR><A name=3Dipc__posix_shm>
<H3>IPC: POSIX shared memory</H3></A>
<DIV class=3Dref_funcs>
<UL>
  <LI>shm_open=20
  <LI>mmap=20
  <LI>shm_unlink </LI></UL></DIV><BR>
<DIV class=3Dnotes><A =
name=3Dipc__posix_shm_notes><B>Notes:</B></A><BR>Shared memory=20
is what the name says about it: a segment of memory shared between =
several=20
processes. UNIX knows System V shared memory and POSIX shared memory. =
This=20
covers the POSIX way, but the other one is just matter of different =
system call=20
names for initializing and terminating the segment.<BR>Shared memory in =
UNIX is=20
based on the concept of <I>memory mapping</I>. The segment of memory =
shared is=20
coupled with an actual file in the filesystem. The file content is =
(ideally) a=20
mirror of the memory segment at any time. The mapping between the shared =
segment=20
content and the mapped file is persistent. The mapped file can be moved =
(even=20
replicated) arbitrarily; this turns often suitable for reimporting such=20
<I>image</I> of the memory segment across different runs of the same =
process (or=20
different ones too) [See Further notes on mapping, below].<BR>In fact, =
keeping=20
an image file of the memory segment is occasionally useless. =
<I>Anonymous=20
mapping</I> is when a shared segment isn't mapped to any actual object =
in the=20
filesystem. This behavior is requested either explicitly (BSD way) or =
via=20
<TT>/dev/zero</TT>, depending on the implementation [See Further notes =
on=20
anonymous mapping, below].<BR>In POSIX shared memory, the memory segment =
is=20
mapped onto a posix object; consequently, it suffers the same problem =
discussed=20
in <A =
href=3D"http://mij.oltrelinux.com/devel/unixprg/#ipc__posix_objects">note=
s=20
on POSIX objects</A> below. The <TT>shm_open()</TT> function is used to =
create=20
such object (or open an existing one). The core function <TT>mmap()</TT> =
is then=20
used to actually attach a memory segment of user-defined size into the =
address=20
space of the process and map its content to the one of the ipc object =
(in case=20
of open existing object, the former content is also imported). =
Thereafter, if=20
other processes shm_open and mmap the same memory object, the memory =
segment=20
will be effectively <I>shared</I>.<BR>Please mind that shared memory is =
natural=20
when working with threads in place of tasks. Threading is frequently =
used as a=20
quick quirk when shared memory is wanted. Similarly, programming with =
shared=20
memory requires many of the programmer attentions discussed for threads: =
usually=20
shared memory is used in conjunction with some form of synchronization, =
often=20
semaphores.<BR>A segment of memory mapped into a process' address space =
will=20
never be detached unless the <TT>munmap()</TT> is called. A posix shared =
memory=20
object will persist unless the <TT>shm_unlink()</TT> function is used =
(or=20
manually removed from the filesystem, where possible).<BR>
<TABLE class=3Dfigures cellPadding=3D10>
  <TBODY>
  <TR>
    <TD align=3Dmiddle><A=20
      =
href=3D"http://mij.oltrelinux.com/devel/unixprg/figures/full/shm_fse_acce=
ssibility.png"><IMG=20
      =
src=3D"http://mij.oltrelinux.com/devel/unixprg/figures/thumbs/shm_fse_acc=
essibility_thumb.png"=20
      width=3D200 height=3D78></A></TD>
    <TD align=3Dmiddle><A=20
      =
href=3D"http://mij.oltrelinux.com/devel/unixprg/figures/full/shm_fsd_acce=
ssibility.png"><IMG=20
      =
src=3D"http://mij.oltrelinux.com/devel/unixprg/figures/thumbs/shm_fsd_acc=
essibility_thumb.png"></A></TD></TR>
  <TR>
    <TD align=3Dmiddle>Figure 1</TD>
    <TD align=3Dmiddle>Figure 2</TD>
  <TR></TR></TBODY></TABLE><B>Further notes on mapping:</B><BR>The mmap =
function=20
maps objects into the process' address space. Mmap does two things: it =
causes=20
the kernel to allocate and attach to the process address space a =
suitable number=20
of page for covering the size requested by the user, and it establish =
the=20
mapping between the object content and the memory content.<BR>When mmap =
is=20
called, the kernel allocates a suitable number of pages to cover the =
size=20
requested by the user. Being memory allocation quantized, the real =
memory=20
allocated into the process address space is rarely large what the user =
asked=20
for. In contrast, files on disk can be stretched to whatever size byte =
by byte.=20
Several effects raise from this fact. Figure 1 illustrates what happens =
when the=20
memory segment size and mapped file size requested are equal, but not =
multiple=20
of the page size. Figure 2 shows what happens when the size of the =
mapped file=20
is shorter than the size requested for the memory segment. =
<BR><BR><B>Further=20
notes on anonymous mapping:</B><BR>Anonymous mapping is used share =
memory=20
segment without mapping it to a persistent object (posix object, or =
file). It is=20
the shared memory counterpart of unnamed semaphores, pipes etc. With =
this role,=20
it is clear that anonymous mapping can only occur between related =
processes.=20
From this mechanism, shared memory benefits in terms of performance. The =

developer is also advantaged not having to handle any persistent=20
object.<BR>There are 2 ways to get anonymous memory mapping. BSD =
provides a=20
special flag (MAP_ANON) for <TT>mmap()</TT> to state this wish =
explicitly. Linux=20
implements the same feature since version 2.4, but in general this is =
not a=20
portable way to carry out the job.<BR>System V (SVR4) doesn't provided =
such=20
method, but the <TT>/dev/zero</TT> file can be used for the same =
purpose. Upon=20
opening, the memory segment is initialized with the content read from =
the file=20
(which is always 0s for this special file). Hereafter, whatever the =
kernel will=20
write on the special file for mirroring from memory will be just =
discarded by=20
the kernel. </DIV><BR>
<DIV class=3Dsummary><A =
name=3Dipc__posix_shm_summary><B>Summary:</B></A><BR>
<UL>
  <LI>what to #include: <TT>sys/types.h</TT> , <TT>sys/mman.h</TT> , =
possibly=20
  <TT>fcntl.h</TT> for O_* macros=20
  <LI>functions:=20
  <OL>
    <LI><TT>int <B>shm_open</B>(const char *name, int flags, mode_t=20
    mode)</TT><BR>open (or create) a shared memory object with the given =
POSIX=20
    name. The <TT>flags</TT> argument instructs on how to open the =
object: the=20
    most relevant ones are O_RDONLY xor O_RDWR for access type, and =
O_CREAT for=20
    create if object doesn't exist. <TT>mode</TT> is only used when the =
object=20
    is to be created, and specifies its access permission (umask=20
    style).<BR>Returns a file descriptor if successful, otherwise =
<TT>-1</TT>.=20
    <LI><TT>void *<B>mmap</B>(void *start_addr, size_t len, int =
protection, int=20
    flags, int fd, off_t offset)</TT><BR>maps the file <TT>fd</TT> into =
memory,=20
    starting from <TT>offset</TT> for a segment long <TT>len</TT>. =
<TT>len</TT>=20
    is preferably a multiple of the system page size; the actual size =
alloced is=20
    the smallest number of pages needed for containing the length =
requested.=20
    Notably, if the file is shorter than <TT>offset</TT> + <TT>len</TT>, =
the=20
    orphaned portion is still available for accessing, but what's =
written to it=20
    is not persistent.<BR><TT>protection</TT> specifies the rules for =
accessing=20
    the segment: PROT_READ , PROT_WRITE, PROT_EXEC to be ORed =
appropriately.=20
    <TT>flags</TT> sets some details on how the segment will be mapped, =
the most=20
    relevant ones being private (MAP_PRIVATE) or shared (MAP_SHARED, =
default)=20
    and, on the systems supporting it, if it is an anonymous segment =
(MAP_ANON),=20
    in which case <TT>fd</TT> is good to be -1. <TT>fd</TT> is simply =
the file=20
    descriptor as returned by shm_open.=20
    <LI><TT>int <B>shm_unlink</B>(const char *name)</TT><BR>removes a =
shared=20
    memory object specified by <TT>name</TT>. If some process is still =
using the=20
    shared memory segment associated to <TT>name</TT>, the segment is =
not=20
    removed until all references to it have been closed. Commonly,=20
    <TT>shm_unlink</TT> is called right after a successful =
<TT>shm_create</TT>,=20
    in order to assure the memory object will be freed as soon as it's =
no longer=20
    used. </LI></OL>
  <LI><I>anonymous mapping</I> is useful when the persistence of the =
shared=20
  segment isn't requested, but like all unnamed mechanisms it only works =
between=20
  related processes. Two methods are available throughout the different =
OSes:=20
  <OL>
    <LI>BSD4.4 anonymous memory mapping: the mmap function is passed -1 =
as=20
    <TT>fd</TT> and an ored MAP_ANON in <TT>flags</TT>. The offset =
argument is=20
    ignored. The filesystem isn't touched at all.=20
    <LI>System V anonymous mapping: the <TT>/dev/zero</TT> file is =
opened to be=20
    passed to mmap. Then, the segment content is initially set to 0, and =

    everything written to it is lost. This machanism also works with =
systems=20
    supporting the BSD way, of course. </LI></OL></LI></UL></DIV><BR>
<DIV class=3Dexamples><A =
name=3Dipc__posix_shm_examples><B>Examples:</B></A><BR>1)=20
Two processes: a server creates a mapped memory segment and produces a =
message=20
on it, then terminates. The client opens the persistent object mapping =
that=20
memory and reads back the message left. The mapped object acts like a =
persistent=20
memory image in this example.=20
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  shm_msgserver.c
 * =20
 *  Illustrates memory mapping and persistence, with POSIX objects.
 *  This process produces a message leaving it in a shared segment.
 *  The segment is mapped in a persistent object meant to be =
subsequently
 *  open by a shared memory "client".
 *
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on 27/08/05.
 *  Original source file available at =
http://mij.oltrelinux.com/devel/unixprg/
 *
 */</SPAN>


<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
</SPAN><SPAN class=3Dccom>/* shm_* stuff, and mmap() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;sys/mman.h&gt;
#include &lt;sys/types.h&gt;
</SPAN><SPAN class=3Dccom>/* exit() etc */</SPAN>
<SPAN class=3Dcpdr>#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;
</SPAN><SPAN class=3Dccom>/* for random() stuff */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
</SPAN>

<SPAN class=3Dccom>/* Posix IPC object name [system dependant] - see
http://mij.oltrelinux.com/devel/unixprg/index2.html#ipc__posix_objects =
*/</SPAN>
<SPAN class=3Dcpdr>#define SHMOBJ_PATH         "/foo1423"
</SPAN><SPAN class=3Dccom>/* maximum length of the content of the =
message */</SPAN>
<SPAN class=3Dcpdr>#define MAX_MSG_LENGTH      </SPAN><SPAN =
class=3Dcval>50</SPAN><SPAN class=3Dcpdr>
</SPAN><SPAN class=3Dccom>/* how many types of messages we recognize =
(fantasy) */</SPAN>
<SPAN class=3Dcpdr>#define TYPES               </SPAN><SPAN =
class=3Dcval>8</SPAN><SPAN class=3Dcpdr>
</SPAN>
<SPAN class=3Dccom>/* message structure for messages in the shared =
segment */</SPAN>
<SPAN class=3Dctyp>struct</SPAN> msg_s {
    <SPAN class=3Dctyp>int</SPAN> type;
    <SPAN class=3Dctyp>char</SPAN> content[MAX_MSG_LENGTH];
};


<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>(<SPAN =
class=3Dctyp>int</SPAN> argc, <SPAN class=3Dctyp>char</SPAN> *argv[]) {
    <SPAN class=3Dctyp>int</SPAN> shmfd;
    <SPAN class=3Dctyp>int</SPAN> shared_seg_size =3D (<SPAN =
class=3Dcval>1</SPAN> * <SPAN class=3Dctyp>sizeof</SPAN>(<SPAN =
class=3Dctyp>struct</SPAN> msg_s));   <SPAN class=3Dccom>/* want shared =
segment capable of storing 1 message */</SPAN>
    <SPAN class=3Dctyp>struct</SPAN> msg_s *shared_msg;      <SPAN =
class=3Dccom>/* the shared segment, and head of the messages list =
*/</SPAN>
   =20

    <SPAN class=3Dccom>/* creating the shared memory object    --  =
shm_open()  */</SPAN>
    shmfd =3D <SPAN class=3Dcfun>shm_open</SPAN>(SHMOBJ_PATH, O_CREAT | =
O_EXCL | O_RDWR, S_IRWXU | S_IRWXG);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(shmfd &lt; =
<SPAN class=3Dcval>0</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
shm_open()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }
    <SPAN class=3Dcfun>fprintf</SPAN>(stderr, <SPAN =
class=3Dcstr>"Created shared memory object %s\n"</SPAN>, SHMOBJ_PATH);
   =20
    <SPAN class=3Dccom>/* adjusting mapped file size (make room for the =
whole segment to map)      --  ftruncate() */</SPAN>
    <SPAN class=3Dcfun>ftruncate</SPAN>(shmfd, shared_seg_size);

    <SPAN class=3Dccom>/* requesting the shared segment    --  mmap() =
*/</SPAN>   =20
    shared_msg =3D (<SPAN class=3Dctyp>struct</SPAN> msg_s *)<SPAN =
class=3Dcfun>mmap</SPAN>(<SPAN class=3Dctyp>NULL</SPAN>, =
shared_seg_size, PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, <SPAN =
class=3Dcval>0</SPAN>);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(shared_msg =
=3D=3D <SPAN class=3Dctyp>NULL</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
mmap()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }
    <SPAN class=3Dcfun>fprintf</SPAN>(stderr, <SPAN class=3Dcstr>"Shared =
memory segment allocated correctly (%d bytes).\n"</SPAN>, =
shared_seg_size);

   =20
    <SPAN class=3Dcfun>srandom</SPAN>(<SPAN =
class=3Dcfun>time</SPAN>(<SPAN class=3Dctyp>NULL</SPAN>));
    <SPAN class=3Dccom>/* producing a message on the shared segment =
*/</SPAN>
    shared_msg-&gt;type =3D <SPAN class=3Dcfun>random</SPAN>() % TYPES;
    <SPAN class=3Dcfun>snprintf</SPAN>(shared_msg-&gt;content, =
MAX_MSG_LENGTH, <SPAN class=3Dcstr>"My message, type %d, num =
%ld"</SPAN>, shared_msg-&gt;type, <SPAN class=3Dcfun>random</SPAN>());

  =20
    <SPAN class=3Dccom>/* [uncomment if you wish] requesting the removal =
of the shm object     --  shm_unlink() */</SPAN>
<SPAN class=3Dccom>/*
    if (shm_unlink(SHMOBJ_PATH) !=3D 0) {
        perror("In shm_unlink()");
        exit(1);
    }
*/</SPAN>

    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}</PRE></DIV><BR>
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  shm_msgclient.c
 * =20
 *  Illustrates memory mapping and persistence, with POSIX objects.
 *  This process reads and displays a message left it in "memory segment
 *  image", a file been mapped from a memory segment.
 *
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on 27/08/05.
 *  Original source file available at =
http://mij.oltrelinux.com/devel/unixprg/
 *
 */</SPAN>

<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
</SPAN><SPAN class=3Dccom>/* exit() etc */</SPAN>
<SPAN class=3Dcpdr>#include &lt;unistd.h&gt;
</SPAN><SPAN class=3Dccom>/* shm_* stuff, and mmap() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;sys/mman.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;
</SPAN><SPAN class=3Dccom>/* for random() stuff */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
</SPAN>

<SPAN class=3Dccom>/* Posix IPC object name [system dependant] - see
http://mij.oltrelinux.com/devel/unixprg/index2.html#ipc__posix_objects =
*/</SPAN>
<SPAN class=3Dcpdr>#define SHMOBJ_PATH         "/foo1423"     =20
</SPAN><SPAN class=3Dccom>/* maximum length of the content of the =
message */</SPAN>
<SPAN class=3Dcpdr>#define MAX_MSG_LENGTH      </SPAN><SPAN =
class=3Dcval>50</SPAN><SPAN class=3Dcpdr>
</SPAN><SPAN class=3Dccom>/* how many types of messages we recognize =
(fantasy) */</SPAN>
<SPAN class=3Dcpdr>#define TYPES               </SPAN><SPAN =
class=3Dcval>8</SPAN><SPAN class=3Dcpdr>
</SPAN>
<SPAN class=3Dccom>/* message structure for messages in the shared =
segment */</SPAN>
<SPAN class=3Dctyp>struct</SPAN> msg_s {
    <SPAN class=3Dctyp>int</SPAN> type;
    <SPAN class=3Dctyp>char</SPAN> content[MAX_MSG_LENGTH];
};


<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>(<SPAN =
class=3Dctyp>int</SPAN> argc, <SPAN class=3Dctyp>char</SPAN> *argv[]) {
    <SPAN class=3Dctyp>int</SPAN> shmfd;
    <SPAN class=3Dctyp>int</SPAN> shared_seg_size =3D (<SPAN =
class=3Dcval>1</SPAN> * <SPAN class=3Dctyp>sizeof</SPAN>(<SPAN =
class=3Dctyp>struct</SPAN> msg_s));   <SPAN class=3Dccom>/* want shared =
segment capable of storing 1 message */</SPAN>
    <SPAN class=3Dctyp>struct</SPAN> msg_s *shared_msg;      <SPAN =
class=3Dccom>/* the shared segment, and head of the messages list =
*/</SPAN>
   =20

    <SPAN class=3Dccom>/* creating the shared memory object    --  =
shm_open()  */</SPAN>
    shmfd =3D <SPAN class=3Dcfun>shm_open</SPAN>(SHMOBJ_PATH, O_RDWR, =
S_IRWXU | S_IRWXG);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(shmfd &lt; =
<SPAN class=3Dcval>0</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
shm_open()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Created shared =
memory object %s\n"</SPAN>, SHMOBJ_PATH);
   =20
    <SPAN class=3Dccom>/* requesting the shared segment    --  mmap() =
*/</SPAN>   =20
    shared_msg =3D (<SPAN class=3Dctyp>struct</SPAN> msg_s *)<SPAN =
class=3Dcfun>mmap</SPAN>(<SPAN class=3Dctyp>NULL</SPAN>, =
shared_seg_size, PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, <SPAN =
class=3Dcval>0</SPAN>);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(shared_msg =
=3D=3D <SPAN class=3Dctyp>NULL</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
mmap()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Shared memory =
segment allocated correctly (%d bytes).\n"</SPAN>, shared_seg_size);


    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"Message type is =
%d, content is: %s\n"</SPAN>, shared_msg-&gt;type, =
shared_msg-&gt;content);
   =20
    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}
</PRE></DIV><BR>You can download the original ascii source files with =
these=20
links: <A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/ipc__shm/1/shm_msgcl=
ient.c"><TT>shm_msgclient.c</TT></A>=20
and <A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/ipc__shm/1/shm_msgse=
rver.c"><TT>shm_msgserver.c</TT></A>.<BR>Compile=20
with:<BR><TT>gcc --ansi --Wall -o shm_msgserver shm_msgserver.c</TT>=20
and<BR><TT>gcc --ansi --Wall -o shm_msgclient =
shm_msgclient.c</TT><BR>(some=20
systems wrap these functions into a posix realtime library: add =
<TT>-lrt</TT>=20
for them -- e.g. Linux does)<BR>Run the=20
following:<BR><TT>./shm_msgserver<BR>./shm_msgclient </TT></DIV><BR>
<HR>
2) Example on BSD asonymous memory mapping. The process gets a =
semaphore,=20
establishes an anonymous memory mapping and forks (so the data space get =

independent). Both the parent and the child, in mutex, update the value =
of the=20
shared segment by random quantities.=20
<DIV class=3Dcsource><PRE><SPAN class=3Dccom>/*
 *  shm_anon_bsd.c
 * =20
 *  Anonymous shared memory via BSD's MAP_ANON.
 *  Create a semaphore, create an anonymous memory segment with the =
MAP_ANON
 *  BSD flag and loop updating the segment content (increment casually) =
with
 *  short intervals.
 *
 *
 *  Created by Mij &lt;mij@bitchx.it&gt; on 29/08/05.
 *  Original source file available at =
http://mij.oltrelinux.com/devel/unixprg/
 *
 */</SPAN>

<SPAN class=3Dcpdr>#include &lt;stdio.h&gt;
</SPAN><SPAN class=3Dccom>/* for shm_* and mmap() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;fcntl.h&gt;
</SPAN><SPAN class=3Dccom>/* for getpid() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;unistd.h&gt;
</SPAN><SPAN class=3Dccom>/* exit() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;stdlib.h&gt;
</SPAN><SPAN class=3Dccom>/* for sem_* functions */</SPAN>
<SPAN class=3Dcpdr>#include &lt;sys/stat.h&gt;
#include &lt;semaphore.h&gt;
</SPAN><SPAN class=3Dccom>/* for seeding time() */</SPAN>
<SPAN class=3Dcpdr>#include &lt;time.h&gt;
</SPAN>
<SPAN class=3Dccom>/* name of the semaphore */</SPAN>
<SPAN class=3Dcpdr>#define     SEMOBJ_NAME         "/semshm"
</SPAN><SPAN class=3Dccom>/* maximum number of seconds to sleep between =
each loop operation */</SPAN>
<SPAN class=3Dcpdr>#define     MAX_SLEEP_SECS      </SPAN><SPAN =
class=3Dcval>3</SPAN><SPAN class=3Dcpdr>
</SPAN><SPAN class=3Dccom>/* maximum value to increment the counter by =
*/</SPAN>
<SPAN class=3Dcpdr>#define     MAX_INC_VALUE       </SPAN><SPAN =
class=3Dcval>10</SPAN><SPAN class=3Dcpdr>=20
</SPAN>

<SPAN class=3Dctyp>int</SPAN> <SPAN class=3Dcfun>main</SPAN>(<SPAN =
class=3Dctyp>int</SPAN> argc, <SPAN class=3Dctyp>char</SPAN> *argv[]) {
    <SPAN class=3Dctyp>int</SPAN> shmfd;
    <SPAN class=3Dctyp>int</SPAN> shared_seg_size =3D <SPAN =
class=3Dcval>2</SPAN> * <SPAN class=3Dctyp>sizeof</SPAN>(<SPAN =
class=3Dctyp>int</SPAN>);
    <SPAN class=3Dctyp>int</SPAN> *shared_values;     <SPAN =
class=3Dccom>/* this will be a (shared) array of 2 elements */</SPAN>
    sem_t *sem_shmsegment;  <SPAN class=3Dccom>/* semaphore controlling =
access to the shared segment */</SPAN>
    pid_t mypid;
   =20
   =20
    <SPAN class=3Dccom>/* getting a new semaphore for the shared segment =
      -- sem_open()   */</SPAN>
    sem_shmsegment =3D <SPAN class=3Dcfun>sem_open</SPAN>(SEMOBJ_NAME, =
O_CREAT | O_EXCL, S_IRWXU | S_IRWXG, <SPAN class=3Dcval>1</SPAN>);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>((<SPAN =
class=3Dctyp>int</SPAN>)sem_shmsegment =3D=3D SEM_FAILED) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
sem_open()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }
    <SPAN class=3Dccom>/* requesting the semaphore not to be held when =
completely unreferenced */</SPAN>
    <SPAN class=3Dcfun>sem_unlink</SPAN>(SEMOBJ_NAME);
   =20
    <SPAN class=3Dccom>/* requesting the shared segment    --  mmap() =
*/</SPAN>   =20
    shared_values =3D (<SPAN class=3Dctyp>int</SPAN> *)<SPAN =
class=3Dcfun>mmap</SPAN>(<SPAN class=3Dctyp>NULL</SPAN>, =
shared_seg_size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -<SPAN =
class=3Dcval>1</SPAN>, <SPAN class=3Dcval>0</SPAN>);
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>((<SPAN =
class=3Dctyp>int</SPAN>)shared_values =3D=3D -<SPAN =
class=3Dcval>1</SPAN>) {
        <SPAN class=3Dcfun>perror</SPAN>(<SPAN class=3Dcstr>"In =
mmap()"</SPAN>);
        <SPAN class=3Dcfun>exit</SPAN>(<SPAN class=3Dcval>1</SPAN>);
    }
    <SPAN class=3Dcfun>fprintf</SPAN>(stderr, <SPAN class=3Dcstr>"Shared =
memory segment allocated correctly (%d bytes) at %u.\n"</SPAN>, =
shared_seg_size, (<SPAN class=3Dctyp>unsigned</SPAN> <SPAN =
class=3Dctyp>int</SPAN>)shared_values);
    <SPAN class=3Dcfun>close</SPAN>(shmfd);


    <SPAN class=3Dccom>/* dupping the process */</SPAN>
    <SPAN class=3Dctyp>if</SPAN><SPAN class=3Dcfun> </SPAN>(! <SPAN =
class=3Dcfun>fork</SPAN>() )
        <SPAN class=3Dccom>/* the child waits 2 seconds for better =
seeding srandom() */</SPAN>
        <SPAN class=3Dcfun>sleep</SPAN>(<SPAN class=3Dcval>2</SPAN>);
   =20
    <SPAN class=3Dccom>/* seeding the random number generator (% x for =
better seeding when child executes close) */</SPAN>
    <SPAN class=3Dcfun>srandom</SPAN>(<SPAN =
class=3Dcfun>time</SPAN>(<SPAN class=3Dctyp>NULL</SPAN>));

    <SPAN class=3Dccom>/* getting my pid, and introducing myself =
*/</SPAN>
    mypid =3D <SPAN class=3Dcfun>getpid</SPAN>();
    <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"My pid is =
%d\n"</SPAN>, mypid);   =20

    <SPAN class=3Dccom>/*
       main loop:
        - pause
        - print the old value
        - choose (and store) a random quantity
        - increment the segment by that
    */</SPAN>
    <SPAN class=3Dctyp>do</SPAN> {
        <SPAN class=3Dcfun>sleep</SPAN>(<SPAN =
class=3Dcfun>random</SPAN>() % (MAX_SLEEP_SECS+<SPAN =
class=3Dcval>1</SPAN>));       <SPAN class=3Dccom>/* pausing for at most =
MAX_SLEEP_SECS seconds */</SPAN>
       =20
        <SPAN class=3Dcfun>sem_wait</SPAN>(sem_shmsegment);
        <SPAN class=3Dccom>/* entered the critical region */</SPAN>
       =20
        <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>"process %d. =
Former value %d."</SPAN>, mypid, shared_values[<SPAN =
class=3Dcval>0</SPAN>]);
       =20
        shared_values[<SPAN class=3Dcval>1</SPAN>] =3D <SPAN =
class=3Dcfun>random</SPAN>() % (MAX_INC_VALUE+<SPAN =
class=3Dcval>1</SPAN>);            <SPAN class=3Dccom>/* choose a random =
value up to MAX_INC_VALUE */</SPAN>
        shared_values[<SPAN class=3Dcval>0</SPAN>] +=3D =
shared_values[<SPAN class=3Dcval>1</SPAN>];   <SPAN class=3Dccom>/* and =
increment the first cell by this value */</SPAN>
       =20
        <SPAN class=3Dcfun>printf</SPAN>(<SPAN class=3Dcstr>" =
Incrementing by %d.\n"</SPAN>, shared_values[<SPAN =
class=3Dcval>1</SPAN>]);

        <SPAN class=3Dccom>/* leaving the critical region */</SPAN>
        <SPAN class=3Dcfun>sem_post</SPAN>(sem_shmsegment);
    } <SPAN class=3Dctyp>while</SPAN><SPAN class=3Dcfun> </SPAN>(<SPAN =
class=3Dcval>1</SPAN>);
   =20
    <SPAN class=3Dccom>/* freeing the reference to the semaphore =
*/</SPAN>
    <SPAN class=3Dcfun>sem_close</SPAN>(sem_shmsegment);

   =20
    <SPAN class=3Dctyp>return</SPAN> <SPAN class=3Dcval>0</SPAN>;
}
</PRE></DIV><BR>You can download the original ascii source with this =
link: <A=20
href=3D"http://mij.oltrelinux.com/devel/unixprg/srcs/ipc__shm/2/shm_anon_=
bsd.c"><TT>shm_anon_bsd.c</TT></A>.<BR>Compile=20
with:<BR><TT>gcc --Wall -lrt -o shm_anon_bsd shm_anon_bsd.c</TT><BR>Run =
the=20
following: <TT>./shm_anon_bsd</TT>=20
<DIV></DIV><BR>
<HR>
<A name=3Dipc__posix_objects>
<H3>IPC: notes on POSIX objects -- the POSIX objects mess</H3></A>
<DIV class=3Dref_funcs>
<UL>
  <LI>posix message queues=20
  <LI>posix named semaphores=20
  <LI>posix shared memory </LI></UL></DIV>
<DIV class=3Dnotes><A name=3Dipc__posix_objects_notes><B>Notes:</B></A> =
The POSIX=20
API makes frequent use of "posix objects". Posix objects are for =
instance=20
semaphores, shared memory segments or message queues. From the =
programmer point=20
of view, they are simply referenced by an identificator, which is a =
string: the=20
POSIX object name.<BR>POSIX objects come in play when persistence is =
required.=20
In the semaphore example, the value of the semaphore needs to be =
preserved=20
across system reboots. A program can create those objects and recall =
them during=20
a later execution by their name.<BR>The problem while using POSIX =
objects is=20
actually their naming. Posix.1 (1003.1-1996) rules the following about =
posix=20
object names:=20
<UL>
  <LI>names must comply the OS rules for pathnames (eg length)=20
  <LI>names must begin with a "/" for different calls to reference the =
same=20
  object=20
  <LI>the behavior on further slashes "/" is implementation specific =
</LI></UL>For=20
Posix, as you see, object names and (filesystem) pathnames are friend =
(naming=20
rules and heading slash). But mapping them in the actual filesystem is =
not=20
pointed out anywhere. The effect is that several different approaches to =
this=20
mapping evolved until today, and the whole mechanism itself is =
non-portable. For=20
example, FreeBSD 5 maps these objects directly into the file system (the =

semaphore named "/tmp/foo" is the actual file "foo" in /tmp), while =
Linux maps=20
them usually under "/dev/shm" (message queue "foo" is file=20
/dev/shm/foo).<BR>Using only one slash, heading, complies to the rules =
but does=20
not help for implementations which maps directly to the filesystem, in =
which the=20
process wouldn't probably have write permission to the root directory =
where the=20
object would be stored. The whole standard covering IPC objects naming =
is=20
useless, there's no portable solution; the developer might use tools =
like=20
autoconf to decide what name to choose at compile time, on the basis of =
the OS=20
for which the code is compiled. A simple solution is to use a "template" =
name,=20
and possibly prefixing it on architectures that map posix object names =
directly=20
to the filesystem. </DIV>
<HR>
<!-- blank space for correct in-page links browsing =
--><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><B=
R><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR=
><BR><BR><BR>
<SCRIPT type=3Dtext/javascript>=0A=
            var gaJsHost =3D (("https:" =3D=3D =
document.location.protocol) ? "https://ssl." : "http://www.");=0A=
            document.write(unescape("%3Cscript src=3D'" + gaJsHost + =
"google-analytics.com/ga.js' type=3D'text/javascript'%3E%3C/script%3E"));=0A=
        </SCRIPT>

<SCRIPT type=3Dtext/javascript>=0A=
            var pageTracker =3D _gat._getTracker("UA-4423487-1");=0A=
            pageTracker._initData();=0A=
            pageTracker._trackPageview();=0A=
        </SCRIPT>
</BODY></HTML>

------=_NextPart_000_0000_01CF39F1.A09848F0
Content-Type: image/png
Content-Transfer-Encoding: base64
Content-Location: http://mij.oltrelinux.com/devel/unixprg/figures/thumbs/shm_fse_accessibility_thumb.png

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

------=_NextPart_000_0000_01CF39F1.A09848F0
Content-Type: image/png
Content-Transfer-Encoding: base64
Content-Location: http://mij.oltrelinux.com/devel/unixprg/figures/thumbs/shm_fsd_accessibility_thumb.png

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
YyBPUyBYKQKNAv8AAAAASUVORK5CYII=

------=_NextPart_000_0000_01CF39F1.A09848F0--
